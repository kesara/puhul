239,242c239,242
<    Network Byte Order:  Here, "network byte order" means most
<       significant byte first, a.k.a. big endian.  All of the integer
<       encodings in this protocol SHALL be transmitted in network byte
<       order.
---
>    Network Byte Order:
>       Here, "network byte order" means most significant byte first,
>       a.k.a. big endian.  All of the integer encodings in this protocol
>       SHALL be transmitted in network byte order.
272,280c272,282
<    TCP Connection:  The term "connection" in this specification
<       exclusively refers to a TCP connection and any and all behaviors,
<       sessions, and other states associated with that TCP connection.
< 
<    TCPCL Session:  A TCPCL session (as opposed to a TCP connection) is a
<       TCPCL communication relationship between two TCPCL entities.  A
<       TCPCL session operates within a single underlying TCP connection,
<       and the lifetime of a TCPCL session is bound to the lifetime of
<       that TCP connection.  A TCPCL session is terminated when the TCP
---
>    TCP Connection:
>       The term "connection" in this specification exclusively refers to
>       a TCP connection and any and all behaviors, sessions, and other
>       states associated with that TCP connection.
> 
>    TCPCL Session:
>       A TCPCL session (as opposed to a TCP connection) is a TCPCL
>       communication relationship between two TCPCL entities.  A TCPCL
>       session operates within a single underlying TCP connection, and
>       the lifetime of a TCPCL session is bound to the lifetime of that
>       TCP connection.  A TCPCL session is terminated when the TCP
294,303c296,307
<    Session Parameters:  These are a set of values used to affect the
<       operation of the TCPCL for a given session.  The manner in which
<       these parameters are conveyed to the bundle entity and thereby to
<       the TCPCL is implementation dependent.  However, the mechanism by
<       which two entities exchange and negotiate the values to be used
<       for a given session is described in Section 4.3.
< 
<    Transfer Stream:  A transfer stream is a unidirectional user-data
<       path within a TCPCL session.  Transfers sent over a transfer
<       stream are serialized, meaning that one transfer must complete its
---
>    Session Parameters:
>       These are a set of values used to affect the operation of the
>       TCPCL for a given session.  The manner in which these parameters
>       are conveyed to the bundle entity and thereby to the TCPCL is
>       implementation dependent.  However, the mechanism by which two
>       entities exchange and negotiate the values to be used for a given
>       session is described in Section 4.3.
> 
>    Transfer Stream:
>       A transfer stream is a unidirectional user-data path within a
>       TCPCL session.  Transfers sent over a transfer stream are
>       serialized, meaning that one transfer must complete its
311,325c315,320
<    Transfer:  This refers to the procedures and mechanisms for
<       conveyance of an individual bundle from one node to another.  Each
<       transfer within the TCPCL is identified by a Transfer ID number,
<       which is guaranteed to be unique only to a single direction within
<       a single session.
< 
<    Transfer Segment:  A transfer segment is a subset of a transfer of
<       user data being communicated over a transfer stream.
< 
<    Idle Session:  A TCPCL session is idle while there is no transmission
<       in progress in either direction.  While idle, the only messages
<       being transmitted or received are KEEPALIVE messages.
< 
<    Live Session:  A TCPCL session is live while there is a transmission
<       in progress in either direction.
---
>    Transfer:
>       This refers to the procedures and mechanisms for conveyance of an
>       individual bundle from one node to another.  Each transfer within
>       the TCPCL is identified by a Transfer ID number, which is
>       guaranteed to be unique only to a single direction within a single
>       session.
327,328c322,337
<    Reason Codes:  The TCPCL uses numeric codes to encode specific
<       reasons for individual failure/error message types.
---
>    Transfer Segment:
>       A transfer segment is a subset of a transfer of user data being
>       communicated over a transfer stream.
> 
>    Idle Session:
>       A TCPCL session is idle while there is no transmission in progress
>       in either direction.  While idle, the only messages being
>       transmitted or received are KEEPALIVE messages.
> 
>    Live Session:
>       A TCPCL session is live while there is a transmission in progress
>       in either direction.
> 
>    Reason Codes:
>       The TCPCL uses numeric codes to encode specific reasons for
>       individual failure/error message types.
403,410c412,421
<    Attempt Session:  The TCPCL allows a BPA to preemptively attempt to
<       establish a TCPCL session with a peer entity.  Each session
<       attempt can send a different set of session negotiation parameters
<       as directed by the BPA.
< 
<    Terminate Session:  The TCPCL allows a BPA to preemptively terminate
<       an established TCPCL session with a peer entity.  The terminate
<       request is done on a per-session basis.
---
>    Attempt Session:
>       The TCPCL allows a BPA to preemptively attempt to establish a
>       TCPCL session with a peer entity.  Each session attempt can send a
>       different set of session negotiation parameters as directed by the
>       BPA.
> 
>    Terminate Session:
>       The TCPCL allows a BPA to preemptively terminate an established
>       TCPCL session with a peer entity.  The terminate request is done
>       on a per-session basis.
416,429c427,442
<       Connecting:  A TCP connection is being established.  This state
<          only applies to the active entity.
< 
<       Contact Negotiating:  A TCP connection has been made (as either
<          the active or passive entity), and contact negotiation has
<          begun.
< 
<       Session Negotiating:  Contact negotiation has been completed
<          (including possible TLS use), and session negotiation has
<          begun.
< 
<       Established:  The session has been fully established and is ready
<          for its first transfer.  When the session is established, the
<          peer node ID (along with an indication of whether or not it was
---
>       Connecting:
>          A TCP connection is being established.  This state only applies
>          to the active entity.
> 
>       Contact Negotiating:
>          A TCP connection has been made (as either the active or passive
>          entity), and contact negotiation has begun.
> 
>       Session Negotiating:
>          Contact negotiation has been completed (including possible TLS
>          use), and session negotiation has begun.
> 
>       Established:
>          The session has been fully established and is ready for its
>          first transfer.  When the session is established, the peer node
>          ID (along with an indication of whether or not it was
441,460c454,464
<    Session Idle Changed:  The TCPCL entity indicates to the BPA when the
<       Live/Idle substate of the session changes.  This occurs only when
<       the top-level session state is "Established".  The session
<       transitions from Idle to Live at the start of a transfer in either
<       transfer stream; the session transitions from Live to Idle at the
<       end of a transfer when the other transfer stream does not have an
<       ongoing transfer.  Because the TCPCL transmits serially over a TCP
<       connection, it suffers from "head-of-queue blocking", so a
<       transfer in either direction can block an immediate start of a new
<       transfer in the session.
< 
<    Begin Transmission:  The principal purpose of the TCPCL is to allow a
<       BPA to transmit bundle data over an established TCPCL session.
<       Transmission requests are done on a per-session basis, and the CL
<       does not necessarily perform any per-session or inter-session
<       queueing.  Any queueing of transmissions is the obligation of the
<       BPA.
< 
<    Transmission Success:  The TCPCL entity indicates to the BPA when a
<       bundle has been fully transferred to a peer entity.
---
>    Session Idle Changed:
>       The TCPCL entity indicates to the BPA when the Live/Idle substate
>       of the session changes.  This occurs only when the top-level
>       session state is "Established".  The session transitions from Idle
>       to Live at the start of a transfer in either transfer stream; the
>       session transitions from Live to Idle at the end of a transfer
>       when the other transfer stream does not have an ongoing transfer.
>       Because the TCPCL transmits serially over a TCP connection, it
>       suffers from "head-of-queue blocking", so a transfer in either
>       direction can block an immediate start of a new transfer in the
>       session.
462,498c466,516
<    Transmission Intermediate Progress:  The TCPCL entity indicates to
<       the BPA the intermediate progress of a transfer to a peer entity.
<       This intermediate progress is at the granularity of each
<       transferred segment.
< 
<    Transmission Failure:  The TCPCL entity indicates to the BPA certain
<       reasons for bundle transmission failure, notably when the peer
<       entity rejects the bundle or when a TCPCL session ends before
<       transfer success.  The TCPCL itself does not have a notion of
<       transfer timeout.
< 
<    Reception Initialized:  The TCPCL entity indicates this status to the
<       receiving BPA just before any transmission data is sent.  This
<       corresponds to reception of the XFER_SEGMENT message with the
<       START flag set to 1.
< 
<    Interrupt Reception:  The TCPCL entity allows a BPA to interrupt an
<       individual transfer before it has fully completed (successfully or
<       not).  Interruption can occur any time after the reception is
<       initialized.
< 
<    Reception Success:  The TCPCL entity indicates to the BPA when a
<       bundle has been fully transferred from a peer entity.
< 
<    Reception Intermediate Progress:  The TCPCL entity indicates to the
<       BPA the intermediate progress of a transfer from the peer entity.
<       This intermediate progress is at the granularity of each
<       transferred segment.  An indication of intermediate reception
<       gives a BPA the chance to inspect bundle header contents before
<       the entire bundle is available and thus supports the "Interrupt
<       Reception" capability.
< 
<    Reception Failure:  The TCPCL entity indicates to the BPA certain
<       reasons for reception failure, notably when the local entity
<       rejects an attempted transfer for some local policy reason or when
<       a TCPCL session ends before transfer success.  The TCPCL itself
<       does not have a notion of transfer timeout.
---
>    Begin Transmission:
>       The principal purpose of the TCPCL is to allow a BPA to transmit
>       bundle data over an established TCPCL session.  Transmission
>       requests are done on a per-session basis, and the CL does not
>       necessarily perform any per-session or inter-session queueing.
>       Any queueing of transmissions is the obligation of the BPA.
> 
>    Transmission Success:
>       The TCPCL entity indicates to the BPA when a bundle has been fully
>       transferred to a peer entity.
> 
>    Transmission Intermediate Progress:
>       The TCPCL entity indicates to the BPA the intermediate progress of
>       a transfer to a peer entity.  This intermediate progress is at the
>       granularity of each transferred segment.
> 
>    Transmission Failure:
>       The TCPCL entity indicates to the BPA certain reasons for bundle
>       transmission failure, notably when the peer entity rejects the
>       bundle or when a TCPCL session ends before transfer success.  The
>       TCPCL itself does not have a notion of transfer timeout.
> 
>    Reception Initialized:
>       The TCPCL entity indicates this status to the receiving BPA just
>       before any transmission data is sent.  This corresponds to
>       reception of the XFER_SEGMENT message with the START flag set to
>       1.
> 
>    Interrupt Reception:
>       The TCPCL entity allows a BPA to interrupt an individual transfer
>       before it has fully completed (successfully or not).  Interruption
>       can occur any time after the reception is initialized.
> 
>    Reception Success:
>       The TCPCL entity indicates to the BPA when a bundle has been fully
>       transferred from a peer entity.
> 
>    Reception Intermediate Progress:
>       The TCPCL entity indicates to the BPA the intermediate progress of
>       a transfer from the peer entity.  This intermediate progress is at
>       the granularity of each transferred segment.  An indication of
>       intermediate reception gives a BPA the chance to inspect bundle
>       header contents before the entire bundle is available and thus
>       supports the "Interrupt Reception" capability.
> 
>    Reception Failure:
>       The TCPCL entity indicates to the BPA certain reasons for
>       reception failure, notably when the local entity rejects an
>       attempted transfer for some local policy reason or when a TCPCL
>       session ends before transfer success.  The TCPCL itself does not
>       have a notion of transfer timeout.
825,846c843,865
<    DTN-Aware CAs:  In the ideal case, the CA or CAs issuing certificates
<       for TCPCL entities are aware of the end use of the certificate,
<       have a mechanism for verifying ownership of a node ID, and are
<       issuing certificates directly for that node ID.  In this
<       environment, the ability to authenticate a peer entity node ID
<       directly avoids the need to authenticate a network name or address
<       and then implicitly trust the node ID of the peer.  The TCPCL
<       authenticates the node ID whenever possible; this is preferred
<       over lower-level PKIX identities.
< 
<    DTN-Ignorant CAs:  It is expected that Internet-scale "public" CAs
<       will continue to focus on DNS names as the preferred PKIX
<       identifier.  There are large infrastructures already in place for
<       managing network-level authentication and protocols to manage
<       identity verification in those environments [RFC8555].  The TCPCL
<       allows for this type of environment by authenticating a lower-
<       level identifier for a peer and requiring the entity to trust that
<       the node ID given by the peer (during session initialization) is
<       valid.  This situation is not ideal, as it allows the
<       vulnerabilities described in Section 7.9, but it still provides
<       some amount of mutual authentication to take place for a TCPCL
<       session.
---
>    DTN-Aware CAs:
>       In the ideal case, the CA or CAs issuing certificates for TCPCL
>       entities are aware of the end use of the certificate, have a
>       mechanism for verifying ownership of a node ID, and are issuing
>       certificates directly for that node ID.  In this environment, the
>       ability to authenticate a peer entity node ID directly avoids the
>       need to authenticate a network name or address and then implicitly
>       trust the node ID of the peer.  The TCPCL authenticates the node
>       ID whenever possible; this is preferred over lower-level PKIX
>       identities.
> 
>    DTN-Ignorant CAs:
>       It is expected that Internet-scale "public" CAs will continue to
>       focus on DNS names as the preferred PKIX identifier.  There are
>       large infrastructures already in place for managing network-level
>       authentication and protocols to manage identity verification in
>       those environments [RFC8555].  The TCPCL allows for this type of
>       environment by authenticating a lower-level identifier for a peer
>       and requiring the entity to trust that the node ID given by the
>       peer (during session initialization) is valid.  This situation is
>       not ideal, as it allows the vulnerabilities described in
>       Section 7.9, but it still provides some amount of mutual
>       authentication to take place for a TCPCL session.
886,890c905,910
<    Persistent Session:  This policy preemptively establishes a single
<       session to known entities in the network and keeps the session
<       active using KEEPALIVEs.  Benefits of this policy include reducing
<       the total amount of TCP data that needs to be exchanged for a set
<       of transfers (assuming that the KEEPALIVE size is significantly
---
>    Persistent Session:
>       This policy preemptively establishes a single session to known
>       entities in the network and keeps the session active using
>       KEEPALIVEs.  Benefits of this policy include reducing the total
>       amount of TCP data that needs to be exchanged for a set of
>       transfers (assuming that the KEEPALIVE size is significantly
902,922c922,942
<    Ephemeral Sessions:  This policy only establishes a session when an
<       outgoing transfer needs to be sent.  Benefits of this policy
<       include not wasting network resources on sessions that are idle
<       for long periods of time and avoiding potential queueing issues as
<       can be seen when using a single persistent session.  Drawbacks
<       include the TCP and TLS overhead of establishing a new session for
<       each transfer.  This policy assumes that each entity can function
<       in a passive role to listen for session requests from any peer
<       that needs to send a transfer; when that is not the case, the
<       polling behavior discussed below needs to happen.  This policy can
<       be augmented to keep the session established as long as any
<       transfers are queued.
< 
<    Active-Only Polling Sessions:  When naming and/or addressing of one
<       entity is variable (i.e., a dynamically assigned IP address or
<       domain name) or when firewall or routing rules prevent incoming
<       TCP connections, that entity can only function in the active role.
<       In these cases, sessions also need to be established when an
<       incoming transfer is expected from a peer or based on a periodic
<       schedule.  This polling behavior causes inefficiencies compared to
<       as-needed ephemeral sessions.
---
>    Ephemeral Sessions:
>       This policy only establishes a session when an outgoing transfer
>       needs to be sent.  Benefits of this policy include not wasting
>       network resources on sessions that are idle for long periods of
>       time and avoiding potential queueing issues as can be seen when
>       using a single persistent session.  Drawbacks include the TCP and
>       TLS overhead of establishing a new session for each transfer.
>       This policy assumes that each entity can function in a passive
>       role to listen for session requests from any peer that needs to
>       send a transfer; when that is not the case, the polling behavior
>       discussed below needs to happen.  This policy can be augmented to
>       keep the session established as long as any transfers are queued.
> 
>    Active-Only Polling Sessions:
>       When naming and/or addressing of one entity is variable (i.e., a
>       dynamically assigned IP address or domain name) or when firewall
>       or routing rules prevent incoming TCP connections, that entity can
>       only function in the active role.  In these cases, sessions also
>       need to be established when an incoming transfer is expected from
>       a peer or based on a periodic schedule.  This polling behavior
>       causes inefficiencies compared to as-needed ephemeral sessions.
945,972c965,994
<    Minimum Overhead:  For a simple network expected to exchange
<       relatively small bundles, the Segment MRU can be set to be
<       identical to the Transfer MRU, which indicates that all transfers
<       can be sent with a single data segment (i.e., no actual
<       segmentation).  If the network is closed and all transmitters are
<       known to follow a single-segment transfer policy, then receivers
<       can avoid the necessity of segment reassembly.  Because this CL
<       operates over a TCP stream, which suffers from a form of head-of-
<       queue blocking between messages, while one entity is transmitting
<       a single XFER_SEGMENT message it is not able to transmit any
<       XFER_ACK or XFER_REFUSE messages for any associated received
<       transfers.
< 
<    Predictable Message Sizing:  In situations where the maximum message
<       size is desired to be well controlled, the Segment MRU can be set
<       to the largest acceptable size (the message size less the
<       XFER_SEGMENT header size) and transmitters can always segment a
<       transfer into maximum-size chunks no larger than the Segment MRU.
<       This guarantees that any single XFER_SEGMENT will not monopolize
<       the TCP stream for too long, which would prevent outgoing XFER_ACK
<       and XFER_REFUSE messages associated with received transfers.
< 
<    Dynamic Segmentation:  Even after negotiation of a Segment MRU for
<       each receiving entity, the actual transfer segmentation only needs
<       to guarantee that any individual segment is no larger than that
<       MRU.  In a situation where TCP throughput is dynamic, the transfer
<       segmentation size can also be dynamic in order to control message
<       transmission duration.
---
>    Minimum Overhead:
>       For a simple network expected to exchange relatively small
>       bundles, the Segment MRU can be set to be identical to the
>       Transfer MRU, which indicates that all transfers can be sent with
>       a single data segment (i.e., no actual segmentation).  If the
>       network is closed and all transmitters are known to follow a
>       single-segment transfer policy, then receivers can avoid the
>       necessity of segment reassembly.  Because this CL operates over a
>       TCP stream, which suffers from a form of head-of-queue blocking
>       between messages, while one entity is transmitting a single
>       XFER_SEGMENT message it is not able to transmit any XFER_ACK or
>       XFER_REFUSE messages for any associated received transfers.
> 
>    Predictable Message Sizing:
>       In situations where the maximum message size is desired to be well
>       controlled, the Segment MRU can be set to the largest acceptable
>       size (the message size less the XFER_SEGMENT header size) and
>       transmitters can always segment a transfer into maximum-size
>       chunks no larger than the Segment MRU.  This guarantees that any
>       single XFER_SEGMENT will not monopolize the TCP stream for too
>       long, which would prevent outgoing XFER_ACK and XFER_REFUSE
>       messages associated with received transfers.
> 
>    Dynamic Segmentation:
>       Even after negotiation of a Segment MRU for each receiving entity,
>       the actual transfer segmentation only needs to guarantee that any
>       individual segment is no larger than that MRU.  In a situation
>       where TCP throughput is dynamic, the transfer segmentation size
>       can also be dynamic in order to control message transmission
>       duration.
1150,1160c1172,1185
<    magic:  A four-octet field that always contains the octet sequence
<       0x64 0x74 0x6E 0x21, i.e., the text string "dtn!" in US-ASCII (and
<       UTF-8).
< 
<    Version:  A one-octet field value containing the value 4 (current
<       version of the TCPCL protocol).
< 
<    Flags:  A one-octet field of single-bit flags, interpreted according
<       to the descriptions in Table 1.  All reserved header flag bits
<       SHALL be set to 0 by the sender.  All reserved header flag bits
<       SHALL be ignored by the receiver.
---
>    magic:
>       A four-octet field that always contains the octet sequence 0x64
>       0x74 0x6E 0x21, i.e., the text string "dtn!" in US-ASCII (and UTF-
>       8).
> 
>    Version:
>       A one-octet field value containing the value 4 (current version of
>       the TCPCL protocol).
> 
>    Flags:
>       A one-octet field of single-bit flags, interpreted according to
>       the descriptions in Table 1.  All reserved header flag bits SHALL
>       be set to 0 by the sender.  All reserved header flag bits SHALL be
>       ignored by the receiver.
1215,1219c1240,1244
<    TCPCL Version:  Both Contact Headers of a successful contact
<       negotiation have identical TCPCL version numbers as described
<       above.  Only upon response of a Contact Header from the passive
<       entity is the TCPCL protocol version established and session
<       negotiation begun.
---
>    TCPCL Version:
>       Both Contact Headers of a successful contact negotiation have
>       identical TCPCL version numbers as described above.  Only upon
>       response of a Contact Header from the passive entity is the TCPCL
>       protocol version established and session negotiation begun.
1278,1294c1303,1321
<    Node ID:  The ideal certificate identity is the node ID of the entity
<       using the NODE-ID, as defined below.  When the node ID is
<       identified, there is no need for any lower-level identification to
<       be present (though it can still be present, and if so it is also
<       validated).
< 
<    DNS Name:  If CA policy forbids a certificate to contain an arbitrary
<       NODE-ID but allows a DNS-ID to be identified, then one or more
<       stable DNS names can be identified in the certificate.  The use of
<       wildcard DNS-IDs is discouraged due to the complex rules for
<       matching and dependence on implementation support for wildcard
<       matching (see Section 6.4.3 of [RFC6125]).
< 
<    Network Address:  If no stable DNS name is available but a stable
<       network address is available and CA policy allows a certificate to
<       contain an IPADDR-ID (as defined below), then one or more network
<       addresses can be identified in the certificate.
---
>    Node ID:
>       The ideal certificate identity is the node ID of the entity using
>       the NODE-ID, as defined below.  When the node ID is identified,
>       there is no need for any lower-level identification to be present
>       (though it can still be present, and if so it is also validated).
> 
>    DNS Name:
>       If CA policy forbids a certificate to contain an arbitrary NODE-ID
>       but allows a DNS-ID to be identified, then one or more stable DNS
>       names can be identified in the certificate.  The use of wildcard
>       DNS-IDs is discouraged due to the complex rules for matching and
>       dependence on implementation support for wildcard matching (see
>       Section 6.4.3 of [RFC6125]).
> 
>    Network Address:
>       If no stable DNS name is available but a stable network address is
>       available and CA policy allows a certificate to contain an IPADDR-
>       ID (as defined below), then one or more network addresses can be
>       identified in the certificate.
1473,1480c1500,1510
<    Absent:  Indicating that no such claims are present in the
<       certificate and the identity cannot be authenticated.
< 
<    Success:  Indicating that one or more such claims are present and at
<       least one matches the peer identity value.
< 
<    Failure:  Indicating that one or more such claims are present and
<       none match the peer identity.
---
>    Absent:
>       Indicating that no such claims are present in the certificate and
>       the identity cannot be authenticated.
> 
>    Success:
>       Indicating that one or more such claims are present and at least
>       one matches the peer identity value.
> 
>    Failure:
>       Indicating that one or more such claims are present and none match
>       the peer identity.
1691,1699c1721,1740
<    Keepalive Interval:  A 16-bit unsigned integer indicating the minimum
<       interval, in seconds, to negotiate as the Session Keepalive using
<       the method described in Section 4.7.
< 
<    Segment MRU:  A 64-bit unsigned integer indicating the largest
<       allowable single-segment data payload size to be received in this
<       session.  Any XFER_SEGMENT sent to this peer SHALL have a data
<       payload no longer than the peer's Segment MRU.  The two entities
<       of a single session MAY have different Segment MRUs, and no
---
>    Keepalive Interval:
>       A 16-bit unsigned integer indicating the minimum interval, in
>       seconds, to negotiate as the Session Keepalive using the method
>       described in Section 4.7.
> 
>    Segment MRU:
>       A 64-bit unsigned integer indicating the largest allowable single-
>       segment data payload size to be received in this session.  Any
>       XFER_SEGMENT sent to this peer SHALL have a data payload no longer
>       than the peer's Segment MRU.  The two entities of a single session
>       MAY have different Segment MRUs, and no relationship between the
>       two is required.
> 
>    Transfer MRU:
>       A 64-bit unsigned integer indicating the largest allowable total-
>       bundle data size to be received in this session.  Any bundle
>       transfer sent to this peer SHALL have a Total Bundle Length
>       payload no longer than the peer's Transfer MRU.  This value can be
>       used to perform proactive bundle fragmentation.  The two entities
>       of a single session MAY have different Transfer MRUs, and no
1702,1721c1743,1755
<    Transfer MRU:  A 64-bit unsigned integer indicating the largest
<       allowable total-bundle data size to be received in this session.
<       Any bundle transfer sent to this peer SHALL have a Total Bundle
<       Length payload no longer than the peer's Transfer MRU.  This value
<       can be used to perform proactive bundle fragmentation.  The two
<       entities of a single session MAY have different Transfer MRUs, and
<       no relationship between the two is required.
< 
<    Node ID Length and Node ID Data:  Together, these fields represent a
<       variable-length text string.  The Node ID Length is a 16-bit
<       unsigned integer indicating the number of octets of Node ID Data
<       to follow.  A zero-length node ID SHALL be used to indicate the
<       lack of a node ID rather than a truly empty node ID.  This case
<       allows an entity to avoid exposing node ID information on an
<       untrusted network.  A non-zero-length Node ID Data SHALL contain
<       the UTF-8 encoded node ID of the entity that sent the SESS_INIT
<       message.  Every node ID SHALL be a URI consistent with the
<       requirements in [RFC3986] and the URI schemes of the IANA "Bundle
<       Protocol URI Scheme Types" registry [IANA-BUNDLE].  The node ID
<       itself can be authenticated as described in Section 4.4.4.
---
>    Node ID Length and Node ID Data:
>       Together, these fields represent a variable-length text string.
>       The Node ID Length is a 16-bit unsigned integer indicating the
>       number of octets of Node ID Data to follow.  A zero-length node ID
>       SHALL be used to indicate the lack of a node ID rather than a
>       truly empty node ID.  This case allows an entity to avoid exposing
>       node ID information on an untrusted network.  A non-zero-length
>       Node ID Data SHALL contain the UTF-8 encoded node ID of the entity
>       that sent the SESS_INIT message.  Every node ID SHALL be a URI
>       consistent with the requirements in [RFC3986] and the URI schemes
>       of the IANA "Bundle Protocol URI Scheme Types" registry
>       [IANA-BUNDLE].  The node ID itself can be authenticated as
>       described in Section 4.4.4.
1762,1771c1796,1805
<    Transfer MTU and Segment MTU:  The Maximum Transmission Unit (MTU)
<       for whole transfers and individual segments is identical to the
<       Transfer MRU and Segment MRU, respectively, of the received
<       SESS_INIT message.  A transmitting peer can send individual
<       segments with any size smaller than the Segment MTU, depending on
<       local policy, dynamic network conditions, etc.  Determining the
<       size of each transmitted segment is an implementation matter.  If
<       either the Transfer MRU or Segment MRU is unacceptable, the entity
<       SHALL terminate the session with a reason code of "Contact
<       Failure".
---
>    Transfer MTU and Segment MTU:
>       The Maximum Transmission Unit (MTU) for whole transfers and
>       individual segments is identical to the Transfer MRU and Segment
>       MRU, respectively, of the received SESS_INIT message.  A
>       transmitting peer can send individual segments with any size
>       smaller than the Segment MTU, depending on local policy, dynamic
>       network conditions, etc.  Determining the size of each transmitted
>       segment is an implementation matter.  If either the Transfer MRU
>       or Segment MRU is unacceptable, the entity SHALL terminate the
>       session with a reason code of "Contact Failure".
1796,1819c1830,1856
<    Item Flags:  A one-octet field containing generic bit flags related
<       to the Item, which are listed in Table 3.  All reserved header
<       flag bits SHALL be set to 0 by the sender.  All reserved header
<       flag bits SHALL be ignored by the receiver.  If a TCPCL entity
<       receives a Session Extension Item with an unknown Item Type and
<       the CRITICAL flag set to 1, the entity SHALL terminate the TCPCL
<       session with a SESS_TERM reason code of "Contact Failure".  If the
<       CRITICAL flag is 0, an entity SHALL skip over and ignore any item
<       with an unknown Item Type.
< 
<    Item Type:  A 16-bit unsigned integer field containing the type of
<       the extension item.  This specification does not define any
<       extension types directly but does create an IANA registry for such
<       codes (see Section 8.3).
< 
<    Item Length:  A 16-bit unsigned integer field containing the number
<       of Item Value octets to follow.
< 
<    Item Value:  A variable-length data field that is interpreted
<       according to the associated Item Type.  This specification places
<       no restrictions on an extension's use of available Item Value
<       data.  Extension specifications SHOULD avoid the use of large data
<       lengths, as no bundle transfers can begin until the full extension
<       data is sent.
---
>    Item Flags:
>       A one-octet field containing generic bit flags related to the
>       Item, which are listed in Table 3.  All reserved header flag bits
>       SHALL be set to 0 by the sender.  All reserved header flag bits
>       SHALL be ignored by the receiver.  If a TCPCL entity receives a
>       Session Extension Item with an unknown Item Type and the CRITICAL
>       flag set to 1, the entity SHALL terminate the TCPCL session with a
>       SESS_TERM reason code of "Contact Failure".  If the CRITICAL flag
>       is 0, an entity SHALL skip over and ignore any item with an
>       unknown Item Type.
> 
>    Item Type:
>       A 16-bit unsigned integer field containing the type of the
>       extension item.  This specification does not define any extension
>       types directly but does create an IANA registry for such codes
>       (see Section 8.3).
> 
>    Item Length:
>       A 16-bit unsigned integer field containing the number of Item
>       Value octets to follow.
> 
>    Item Value:
>       A variable-length data field that is interpreted according to the
>       associated Item Type.  This specification places no restrictions
>       on an extension's use of available Item Value data.  Extension
>       specifications SHOULD avoid the use of large data lengths, as no
>       bundle transfers can begin until the full extension data is sent.
1927,1932c1964,1970
<    Reason Code:  A one-octet refusal reason code interpreted according
<       to the descriptions in Table 4.
< 
<    Rejected Message Header:  The Rejected Message Header is a copy of
<       the Message Header to which the MSG_REJECT message is sent as a
<       response.
---
>    Reason Code:
>       A one-octet refusal reason code interpreted according to the
>       descriptions in Table 4.
> 
>    Rejected Message Header:
>       The Rejected Message Header is a copy of the Message Header to
>       which the MSG_REJECT message is sent as a response.
2032,2035c2070,2074
<    Message Flags:  A one-octet field of single-bit flags, interpreted
<       according to the descriptions in Table 5.  All reserved header
<       flag bits SHALL be set to 0 by the sender.  All reserved header
<       flag bits SHALL be ignored by the receiver.
---
>    Message Flags:
>       A one-octet field of single-bit flags, interpreted according to
>       the descriptions in Table 5.  All reserved header flag bits SHALL
>       be set to 0 by the sender.  All reserved header flag bits SHALL be
>       ignored by the receiver.
2037,2038c2076,2077
<    Transfer ID:  A 64-bit unsigned integer identifying the transfer
<       being made.
---
>    Transfer ID:
>       A 64-bit unsigned integer identifying the transfer being made.
2058,2059c2097,2099
<    Data length:  A 64-bit unsigned integer indicating the number of
<       octets in Data contents to follow.
---
>    Data length:
>       A 64-bit unsigned integer indicating the number of octets in Data
>       contents to follow.
2120,2129c2160,2172
<    Message Flags:  A one-octet field of single-bit flags, interpreted
<       according to the descriptions in Table 5.  All reserved header
<       flag bits SHALL be set to 0 by the sender.  All reserved header
<       flag bits SHALL be ignored by the receiver.
< 
<    Transfer ID:  A 64-bit unsigned integer identifying the transfer
<       being acknowledged.
< 
<    Acknowledged length:  A 64-bit unsigned integer indicating the total
<       number of octets in the transfer that are being acknowledged.
---
>    Message Flags:
>       A one-octet field of single-bit flags, interpreted according to
>       the descriptions in Table 5.  All reserved header flag bits SHALL
>       be set to 0 by the sender.  All reserved header flag bits SHALL be
>       ignored by the receiver.
> 
>    Transfer ID:
>       A 64-bit unsigned integer identifying the transfer being
>       acknowledged.
> 
>    Acknowledged length:
>       A 64-bit unsigned integer indicating the total number of octets in
>       the transfer that are being acknowledged.
2194,2195c2237,2239
<    Reason Code:  A one-octet refusal reason code interpreted according
<       to the descriptions in Table 6.
---
>    Reason Code:
>       A one-octet refusal reason code interpreted according to the
>       descriptions in Table 6.
2197,2198c2241,2242
<    Transfer ID:  A 64-bit unsigned integer identifying the transfer
<       being refused.
---
>    Transfer ID:
>       A 64-bit unsigned integer identifying the transfer being refused.
2263,2285c2307,2333
<    Item Flags:  A one-octet field containing generic bit flags related
<       to the Item, which are listed in Table 7.  All reserved header
<       flag bits SHALL be set to 0 by the sender.  All reserved header
<       flag bits SHALL be ignored by the receiver.  If a TCPCL entity
<       receives a Transfer Extension Item with an unknown Item Type and
<       the CRITICAL flag is 1, the entity SHALL refuse the transfer with
<       a XFER_REFUSE reason code of "Extension Failure".  If the CRITICAL
<       flag is 0, an entity SHALL skip over and ignore any item with an
<       unknown Item Type.
< 
<    Item Type:  A 16-bit unsigned integer field containing the type of
<       the extension item.  This specification creates an IANA registry
<       for such codes (see Section 8.4).
< 
<    Item Length:  A 16-bit unsigned integer field containing the number
<       of Item Value octets to follow.
< 
<    Item Value:  A variable-length data field that is interpreted
<       according to the associated Item Type.  This specification places
<       no restrictions on an extension's use of available Item Value
<       data.  Extension specifications SHOULD avoid the use of large data
<       lengths, as the associated transfer cannot begin until the full
<       extension data is sent.
---
>    Item Flags:
>       A one-octet field containing generic bit flags related to the
>       Item, which are listed in Table 7.  All reserved header flag bits
>       SHALL be set to 0 by the sender.  All reserved header flag bits
>       SHALL be ignored by the receiver.  If a TCPCL entity receives a
>       Transfer Extension Item with an unknown Item Type and the CRITICAL
>       flag is 1, the entity SHALL refuse the transfer with a XFER_REFUSE
>       reason code of "Extension Failure".  If the CRITICAL flag is 0, an
>       entity SHALL skip over and ignore any item with an unknown Item
>       Type.
> 
>    Item Type:
>       A 16-bit unsigned integer field containing the type of the
>       extension item.  This specification creates an IANA registry for
>       such codes (see Section 8.4).
> 
>    Item Length:
>       A 16-bit unsigned integer field containing the number of Item
>       Value octets to follow.
> 
>    Item Value:
>       A variable-length data field that is interpreted according to the
>       associated Item Type.  This specification places no restrictions
>       on an extension's use of available Item Value data.  Extension
>       specifications SHOULD avoid the use of large data lengths, as the
>       associated transfer cannot begin until the full extension data is
>       sent.
2337,2339c2385,2388
<    Total Length:  A 64-bit unsigned integer indicating the size of the
<       data to be transferred.  The Total Length field SHALL be treated
<       as authoritative by the receiver.  If, for whatever reason, the
---
>    Total Length:
>       A 64-bit unsigned integer indicating the size of the data to be
>       transferred.  The Total Length field SHALL be treated as
>       authoritative by the receiver.  If, for whatever reason, the
2424,2430c2473,2481
<    Message Flags:  A one-octet field of single-bit flags, interpreted
<       according to the descriptions in Table 8.  All reserved header
<       flag bits SHALL be set to 0 by the sender.  All reserved header
<       flag bits SHALL be ignored by the receiver.
< 
<    Reason Code:  A one-octet refusal reason code interpreted according
<       to the descriptions in Table 9.
---
>    Message Flags:
>       A one-octet field of single-bit flags, interpreted according to
>       the descriptions in Table 8.  All reserved header flag bits SHALL
>       be set to 0 by the sender.  All reserved header flag bits SHALL be
>       ignored by the receiver.
> 
>    Reason Code:
>       A one-octet refusal reason code interpreted according to the
>       descriptions in Table 9.
3404d3454
< 
3409d3458
< 
3420d3468
< 
3430d3477
< 
