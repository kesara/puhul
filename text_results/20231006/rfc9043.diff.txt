85,86c85,86
<        4.1.1.  "quant_tables"
<        4.1.2.  "context_count"
---
>        4.1.1.  quant_tables
>        4.1.2.  context_count
88,104c88,104
<        4.2.1.  "version"
<        4.2.2.  "micro_version"
<        4.2.3.  "coder_type"
<        4.2.4.  "state_transition_delta"
<        4.2.5.  "colorspace_type"
<        4.2.6.  "chroma_planes"
<        4.2.7.  "bits_per_raw_sample"
<        4.2.8.  "log2_h_chroma_subsample"
<        4.2.9.  "log2_v_chroma_subsample"
<        4.2.10. "extra_plane"
<        4.2.11. "num_h_slices"
<        4.2.12. "num_v_slices"
<        4.2.13. "quant_table_set_count"
<        4.2.14. "states_coded"
<        4.2.15. "initial_state_delta"
<        4.2.16. "ec"
<        4.2.17. "intra"
---
>        4.2.1.  version
>        4.2.2.  micro_version
>        4.2.3.  coder_type
>        4.2.4.  state_transition_delta
>        4.2.5.  colorspace_type
>        4.2.6.  chroma_planes
>        4.2.7.  bits_per_raw_sample
>        4.2.8.  log2_h_chroma_subsample
>        4.2.9.  log2_v_chroma_subsample
>        4.2.10. extra_plane
>        4.2.11. num_h_slices
>        4.2.12. num_v_slices
>        4.2.13. quant_table_set_count
>        4.2.14. states_coded
>        4.2.15. initial_state_delta
>        4.2.16. ec
>        4.2.17. intra
106,107c106,107
<        4.3.1.  "reserved_for_future_use"
<        4.3.2.  "configuration_record_crc_parity"
---
>        4.3.1.  reserved_for_future_use
>        4.3.2.  configuration_record_crc_parity
112,120c112,120
<        4.6.1.  "slice_x"
<        4.6.2.  "slice_y"
<        4.6.3.  "slice_width"
<        4.6.4.  "slice_height"
<        4.6.5.  "quant_table_set_index_count"
<        4.6.6.  "quant_table_set_index"
<        4.6.7.  "picture_structure"
<        4.6.8.  "sar_num"
<        4.6.9.  "sar_den"
---
>        4.6.1.  slice_x
>        4.6.2.  slice_y
>        4.6.3.  slice_width
>        4.6.4.  slice_height
>        4.6.5.  quant_table_set_index_count
>        4.6.6.  quant_table_set_index
>        4.6.7.  picture_structure
>        4.6.8.  sar_num
>        4.6.9.  sar_den
122,125c122,125
<        4.7.1.  "primary_color_count"
<        4.7.2.  "plane_pixel_height"
<        4.7.3.  "slice_pixel_height"
<        4.7.4.  "slice_pixel_y"
---
>        4.7.1.  primary_color_count
>        4.7.2.  plane_pixel_height
>        4.7.3.  slice_pixel_height
>        4.7.4.  slice_pixel_y
127,130c127,130
<        4.8.1.  "plane_pixel_width"
<        4.8.2.  "slice_pixel_width"
<        4.8.3.  "slice_pixel_x"
<        4.8.4.  "sample_difference"
---
>        4.8.1.  plane_pixel_width
>        4.8.2.  slice_pixel_width
>        4.8.3.  slice_pixel_x
>        4.8.4.  sample_difference
132,134c132,134
<        4.9.1.  "slice_size"
<        4.9.2.  "error_status"
<        4.9.3.  "slice_crc_parity"
---
>        4.9.1.  slice_size
>        4.9.2.  error_status
>        4.9.3.  slice_crc_parity
203,206c203,207
<    FFV1:  The chosen name of this video encoding format, which is the
<       short version of "FF Video 1".  The letters "FF" come from
<       "FFmpeg", which is the name of the reference decoder whose first
<       letters originally meant "Fast Forward".
---
>    FFV1:
>       The chosen name of this video encoding format, which is the short
>       version of "FF Video 1".  The letters "FF" come from "FFmpeg",
>       which is the name of the reference decoder whose first letters
>       originally meant "Fast Forward".
209c210
<       (when required) a "Configuration Record" into a bitstream.
---
>       (when required) a Configuration Record into a bitstream.
211,214c212,224
<    Sample:  The smallest addressable representation of a color component
<       or a luma component in a Frame.  Examples of Sample are Luma (Y),
<       Blue-difference Chroma (Cb), Red-difference Chroma (Cr),
<       Transparency, Red, Green, and Blue.
---
>    Sample:
>       The smallest addressable representation of a color component or a
>       luma component in a Frame.  Examples of Sample are Luma (Y), Blue-
>       difference Chroma (Cb), Red-difference Chroma (Cr), Transparency,
>       Red, Green, and Blue.
> 
>    Symbol:
>       A value stored in the bitstream, which is defined and decoded
>       through one of the methods described in Table 4.
> 
>    Line:
>       A discrete component of a static image composed of Samples that
>       represent a specific quantification of Samples of that image.
216,222c226,227
<    Symbol:  A value stored in the bitstream, which is defined and
<       decoded through one of the methods described in Table 4.
< 
<    Line:  A discrete component of a static image composed of Samples
<       that represent a specific quantification of Samples of that image.
< 
<    Plane:  A discrete component of a static image composed of Lines that
---
>    Plane:
>       A discrete component of a static image composed of Lines that
225,229c230,236
<    Pixel:  The smallest addressable representation of a color in a
<       Frame.  It is composed of one or more Samples.
< 
<    MSB:  Most Significant Bit, the bit that can cause the largest change
<       in magnitude of the symbol.
---
>    Pixel:
>       The smallest addressable representation of a color in a Frame.  It
>       is composed of one or more Samples.
> 
>    MSB:
>       Most Significant Bit, the bit that can cause the largest change in
>       magnitude of the symbol.
231c238,239
<    VLC:  Variable Length Code, a code that maps source symbols to a
---
>    VLC:
>       Variable Length Code, a code that maps source symbols to a
234,243c242,253
<    RGB:  A reference to the method of storing the value of a pixel by
<       using three numeric values that represent Red, Green, and Blue.
< 
<    YCbCr:  A reference to the method of storing the value of a pixel by
<       using three numeric values that represent the luma of the pixel
<       (Y) and the chroma of the pixel (Cb and Cr).  The term YCbCr is
<       used for historical reasons and currently references any color
<       space relying on one luma Sample and two chroma Samples, e.g.,
<       YCbCr (luma, blue-difference chroma, red-difference chroma),
<       YCgCo, or ICtCp (intensity, blue-yellow, red-green).
---
>    RGB:
>       A reference to the method of storing the value of a pixel by using
>       three numeric values that represent Red, Green, and Blue.
> 
>    YCbCr:
>       A reference to the method of storing the value of a pixel by using
>       three numeric values that represent the luma of the pixel (Y) and
>       the chroma of the pixel (Cb and Cr).  The term YCbCr is used for
>       historical reasons and currently references any color space
>       relying on one luma Sample and two chroma Samples, e.g., YCbCr
>       (luma, blue-difference chroma, red-difference chroma), YCgCo, or
>       ICtCp (intensity, blue-yellow, red-green).
253,254c263,264
<    [ISO.9899.2018] and uses its "if/else", "while", and "for" keywords
<    as well as functions defined within this document.
---
>    [ISO.9899.2018] and uses its if/else, while, and for keywords as well
>    as functions defined within this document.
257,258c267,268
<    such as shown in Figure 1.  In this form, the "type" column provides
<    a symbol as defined in Table 4 that defines the storage of the data
---
>    such as shown in Figure 1.  In this form, the type column provides a
>    symbol as defined in Table 4 that defines the storage of the data
274,275c284,285
<    ">>" (removal of implementation-defined behavior) and "^" (power
<    instead of XOR) operators, which are redefined within this section.
---
>    >> (removal of implementation-defined behavior) and ^ (power instead
>    of XOR) operators, which are redefined within this section.
277c287
<    "a + b" means a plus b.
---
>    a + b means a plus b.
279c289
<    "a - b" means a minus b.
---
>    a - b means a minus b.
281c291
<    "-a" means negation of a.
---
>    -a means negation of a.
283c293
<    "a * b" means a multiplied by b.
---
>    a * b means a multiplied by b.
285c295
<    "a / b" means a divided by b.
---
>    a / b means a divided by b.
287c297
<    "a ^ b" means a raised to the b-th power.
---
>    a ^ b means a raised to the b-th power.
289c299
<    "a & b" means bitwise "and" of a and b.
---
>    a & b means bitwise "and" of a and b.
291c301
<    "a | b" means bitwise "or" of a and b.
---
>    a | b means bitwise "or" of a and b.
293c303
<    "a >> b" means arithmetic right shift of the two's complement integer
---
>    a >> b means arithmetic right shift of the two's complement integer
297c307
<    "a << b" means arithmetic left shift of the two's complement integer
---
>    a << b means arithmetic left shift of the two's complement integer
302c312
<    "a = b" means a is assigned b.
---
>    a = b means a is assigned b.
304c314
<    "a++" is equivalent to a is assigned a + 1.
---
>    a++ is equivalent to a is assigned a + 1.
306c316
<    "a--" is equivalent to a is assigned a - 1.
---
>    a-- is equivalent to a is assigned a - 1.
308c318
<    "a += b" is equivalent to a is assigned a + b.
---
>    a += b is equivalent to a is assigned a + b.
310c320
<    "a -= b" is equivalent to a is assigned a - b.
---
>    a -= b is equivalent to a is assigned a - b.
312c322
<    "a *= b" is equivalent to a is assigned a * b.
---
>    a *= b is equivalent to a is assigned a * b.
316c326
<    "a > b" is true when a is greater than b.
---
>    a > b is true when a is greater than b.
318c328
<    "a >= b" is true when a is greater than or equal to b.
---
>    a >= b is true when a is greater than or equal to b.
320c330
<    "a < b" is true when a is less than b.
---
>    a < b is true when a is less than b.
322c332
<    "a <= b" is true when a is less than or equal b.
---
>    a <= b is true when a is less than or equal b.
324c334
<    "a == b" is true when a is equal to b.
---
>    a == b is true when a is equal to b.
326c336
<    "a != b" is true when a is not equal to b.
---
>    a != b is true when a is not equal to b.
328c338
<    "a && b" is true when both a is true and b is true.
---
>    a && b is true when both a is true and b is true.
330c340
<    "a || b" is true when either a is true or b is true.
---
>    a || b is true when either a is true or b is true.
332c342
<    "!a" is true when a is not true.
---
>    !a is true when a is not true.
334c344
<    "a ? b : c" if a is true, then b, otherwise c.
---
>    a ? b : c if a is true, then b, otherwise c.
338c348
<    "floor(a)" means the largest integer less than or equal to a.
---
>    floor(a) means the largest integer less than or equal to a.
340c350
<    "ceil(a)" means the smallest integer greater than or equal to a.
---
>    ceil(a) means the smallest integer greater than or equal to a.
342c352
<    "sign(a)" extracts the sign of a number, i.e., if a < 0 then -1, else
---
>    sign(a) extracts the sign of a number, i.e., if a < 0 then -1, else
345,346c355
<    "abs(a)" means the absolute value of a, i.e., "abs(a)" = "sign(a) *
<    a".
---
>    abs(a) means the absolute value of a, i.e., abs(a) = sign(a) * a.
348c357
<    "log2(a)" means the base-two logarithm of a.
---
>    log2(a) means the base-two logarithm of a.
350c359
<    "min(a,b)" means the smaller of two values a and b.
---
>    min(a,b) means the smaller of two values a and b.
352c361
<    "max(a,b)" means the larger of two values a and b.
---
>    max(a,b) means the larger of two values a and b.
354,355c363,364
<    "median(a,b,c)" means the numerical middle value in a data set of a,
<    b, and c, i.e., "a+b+c-min(a,b,c)-max(a,b,c)".
---
>    median(a,b,c) means the numerical middle value in a data set of a, b,
>    and c, i.e., a+b+c-min(a,b,c)-max(a,b,c).
357c366
<    "a ==> b" means a implies b.
---
>    a ==> b means a implies b.
359c368
<    "a <==> b" means a ==> b, b ==> a.
---
>    a <==> b means a ==> b, b ==> a.
361c370
<    "a_b" means the b-th value of a sequence of a.
---
>    a_b means the b-th value of a sequence of a.
363c372
<    "a_(b,c)" means the 'b,c'-th value of a sequence of a.
---
>    a_(b,c) means the 'b,c'-th value of a sequence of a.
390c399
<    "a...b" means any value from a to b, inclusive.
---
>    a...b means any value from a to b, inclusive.
394,396c403,405
<    "NumBytes" is a nonnegative integer that expresses the size in 8-bit
<    octets of a particular FFV1 "Configuration Record" or "Frame".  FFV1
<    relies on its container to store the "NumBytes" values; see
---
>    NumBytes is a nonnegative integer that expresses the size in 8-bit
>    octets of a particular FFV1 Configuration Record or Frame.  FFV1
>    relies on its container to store the NumBytes values; see
403,407c412,416
<    "remaining_bits_in_bitstream( NumBytes )" means the count of
<    remaining bits after the pointer in that "Configuration Record" or
<    "Frame".  It is computed from the "NumBytes" value multiplied by 8
<    minus the count of bits of that "Configuration Record" or "Frame"
<    already read by the bitstream parser.
---
>    remaining_bits_in_bitstream( NumBytes ) means the count of remaining
>    bits after the pointer in that Configuration Record or Frame.  It is
>    computed from the NumBytes value multiplied by 8 minus the count of
>    bits of that Configuration Record or Frame already read by the
>    bitstream parser.
411,412c420,421
<    "remaining_symbols_in_syntax( )" is true as long as the range coder
<    has not consumed all the given input bytes.
---
>    remaining_symbols_in_syntax( ) is true as long as the range coder has
>    not consumed all the given input bytes.
416,417c425,426
<    "byte_aligned( )" is true if "remaining_bits_in_bitstream( NumBytes
<    )" is a multiple of 8, otherwise false.
---
>    byte_aligned( ) is true if remaining_bits_in_bitstream( NumBytes ) is
>    a multiple of 8, otherwise false.
421,423c430,432
<    "get_bits( i )" is the action to read the next "i" bits in the
<    bitstream, from most significant bit to least significant bit, and to
<    return the corresponding value.  The pointer is increased by "i".
---
>    get_bits( i ) is the action to read the next i bits in the bitstream,
>    from most significant bit to least significant bit, and to return the
>    corresponding value.  The pointer is increased by i.
427,432c436,441
<    For each "Slice" (as described in Section 4.5) of a Frame, the
<    Planes, Lines, and Samples are coded in an order determined by the
<    color space (see Section 3.7).  Each Sample is predicted by the
<    median predictor as described in Section 3.3 from other Samples
<    within the same Plane, and the difference is stored using the method
<    described in Section 3.8.
---
>    For each Slice (as described in Section 4.5) of a Frame, the Planes,
>    Lines, and Samples are coded in an order determined by the color
>    space (see Section 3.7).  Each Sample is predicted by the median
>    predictor as described in Section 3.3 from other Samples within the
>    same Plane, and the difference is stored using the method described
>    in Section 3.8.
436c445
<    A border is assumed for each coded "Slice" for the purpose of the
---
>    A border is assumed for each coded Slice for the purpose of the
443c452
<       "0".
---
>       0.
450c459
<       two rows of Samples above the coded Slice are assumed to be "0".
---
>       two rows of Samples above the coded Slice are assumed to be 0.
452c461
<    Figure 2 depicts a Slice of nine Samples "a,b,c,d,e,f,g,h,i" in a
---
>    Figure 2 depicts a Slice of nine Samples a,b,c,d,e,f,g,h,i in a
474c483
<    Relative to any Sample "X", six other relatively positioned Samples
---
>    Relative to any Sample X, six other relatively positioned Samples
495,497c504,506
<    The prediction for any Sample value at position "X" may be computed
<    based upon the relative neighboring values of "l", "t", and "tl" via
<    this equation:
---
>    The prediction for any Sample value at position X may be computed
>    based upon the relative neighboring values of l, t, and tl via this
>    equation:
506,508c515,517
<    If "colorspace_type == 0 && bits_per_raw_sample == 16 && ( coder_type
<    == 1 || coder_type == 2 )" (see Sections 4.2.5, 4.2.7, and 4.2.3),
<    the following median predictor MUST be used:
---
>    If colorspace_type == 0 && bits_per_raw_sample == 16 && ( coder_type
>    == 1 || coder_type == 2 ) (see Sections 4.2.5, 4.2.7, and 4.2.3), the
>    following median predictor MUST be used:
553,555c562,564
<    In this formula, "i" is the Quantization Table Set index, "j" is the
<    Quantized Table index, and "k" is the Quantized Sample Difference
<    (see Section 4.1.1).
---
>    In this formula, i is the Quantization Table Set index, j is the
>    Quantized Table index, and k is the Quantized Sample Difference (see
>    Section 4.1.1).
559,560c568,569
<    Relative to any Sample "X", the Quantized Sample Differences "L-l",
<    "l-tl", "tl-t", "T-t", and "t-tr" are used as context:
---
>    Relative to any Sample X, the Quantized Sample Differences L-l, l-tl,
>    tl-t, T-t, and t-tr are used as context:
570,573c579,582
<    If "context >= 0" then "context" is used, and the difference between
<    the Sample and its predicted value is encoded as is; else "-context"
<    is used, and the difference between the Sample and its predicted
<    value is encoded with a flipped sign.
---
>    If context >= 0 then context is used, and the difference between the
>    Sample and its predicted value is encoded as is; else -context is
>    used, and the difference between the Sample and its predicted value
>    is encoded with a flipped sign.
580c589
<    *  For Y Plane, "quant_table_set_index[ 0 ]" index is used.
---
>    *  For Y Plane, quant_table_set_index[ 0 ] index is used.
582c591
<    *  For Cb and Cr Planes, "quant_table_set_index[ 1 ]" index is used.
---
>    *  For Cb and Cr Planes, quant_table_set_index[ 1 ] index is used.
584,585c593,594
<    *  For extra Plane, "quant_table_set_index[ (version <= 3 ||
<       chroma_planes) ? 2 : 1 ]" index is used.
---
>    *  For extra Plane, quant_table_set_index[ (version <= 3 ||
>       chroma_planes) ? 2 : 1 ] index is used.
589c598
<    ("chroma_planes" set to 0), this index is kept for "version <= 3" in
---
>    (chroma_planes set to 0), this index is kept for version <= 3 in
653,657c662,666
<    Cb and Cr are positively offset by "1 << bits_per_raw_sample" after
<    the conversion from RGB to the modified YCbCr, and they are
<    negatively offset by the same value before the conversion from the
<    modified YCbCr to RGB in order to have only nonnegative values after
<    the conversion.
---
>    Cb and Cr are positively offset by 1 << bits_per_raw_sample after the
>    conversion from RGB to the modified YCbCr, and they are negatively
>    offset by the same value before the conversion from the modified
>    YCbCr to RGB in order to have only nonnegative values after the
>    conversion.
684,686c693,695
<    If "bits_per_raw_sample" is between 9 and 15 inclusive and
<    "extra_plane" is 0, the following formulae for reversible conversions
<    between YCbCr and RGB MUST be used instead of the ones above:
---
>    If bits_per_raw_sample is between 9 and 15 inclusive and extra_plane
>    is 0, the following formulae for reversible conversions between YCbCr
>    and RGB MUST be used instead of the ones above:
705,707c714,716
<    of the FFV1 bitstream, when "bits_per_raw_sample" was between 9 and
<    15 inclusive and "extra_plane" was 0, Green Blue Red (GBR) Planes
<    were used as Blue Green Red (BGR) Planes during both encoding and
---
>    of the FFV1 bitstream, when bits_per_raw_sample was between 9 and 15
>    inclusive and extra_plane was 0, Green Blue Red (GBR) Planes were
>    used as Blue Green Red (BGR) Planes during both encoding and
719,720c728,729
<    Figure 10, the term "bits" represents "bits_per_raw_sample + 1" for
<    JPEG 2000 RCT or "bits_per_raw_sample" otherwise:
---
>    Figure 10, the term bits represents bits_per_raw_sample + 1 for JPEG
>    2000 RCT or bits_per_raw_sample otherwise:
763,764c772,774
<    l_i  a temporary variable to carry over or adjust the Low value of
<       the Range between range coding operations.
---
>    l_i
>       a temporary variable to carry over or adjust the Low value of the
>       Range between range coding operations.
766c776,777
<    t_i  a temporary variable to transmit subranges between range coding
---
>    t_i
>       a temporary variable to transmit subranges between range coding
794,795c805,806
<           Figure 13: The initial value for "j", the length of the
<                             bytestream encoding.
---
>       Figure 13: The initial value for j, the length of the bytestream
>                                  encoding.
824c835
<        Figure 16: If the value of "k" is unequal to the i-th value of
---
>         Figure 16: If the value of k is unequal to the i-th value of
917c928
<    FFV1.  The first is in the "Configuration Record", which in this case
---
>    FFV1.  The first is in the Configuration Record, which in this case
919,923c930,934
<    mode.  The second is the switch from the "Slice Header", which is
<    range coded to Golomb-coded Slices as Sentinel mode.  The third is
<    the end of range-coded Slices, which need to terminate before the CRC
<    at their end.  This can be handled as Sentinel mode or as Closed mode
<    if the CRC position has been determined.
---
>    mode.  The second is the switch from the Slice Header, which is range
>    coded to Golomb-coded Slices as Sentinel mode.  The third is the end
>    of range-coded Slices, which need to terminate before the CRC at
>    their end.  This can be handled as Sentinel mode or as Closed mode if
>    the CRC position has been determined.
968,969c979,980
<    "get_symbol" is used for the read out of "sample_difference"
<    indicated in Figure 10.
---
>    get_symbol is used for the read out of sample_difference indicated in
>    Figure 10.
971c982
<    "get_rac" returns a boolean computed from the bytestream as described
---
>    get_rac returns a boolean computed from the bytestream as described
977,978c988,989
<    When the "keyframe" value (see Section 4.4) is 1, all range coder
<    state variables are set to their initial state.
---
>    When the keyframe value (see Section 4.4) is 1, all range coder state
>    variables are set to their initial state.
990c1001
<                  table for a "get_rac" readout value of 1.
---
>                   table for a get_rac readout value of 1.
995c1006
<                  table for a "get_rac" readout value of 0.
---
>                   table for a get_rac readout value of 0.
1039c1050
<    default.  To use it, the "coder_type" (see Section 4.2.3) MUST be set
---
>    default.  To use it, the coder_type (see Section 4.2.3) MUST be set
1041c1052
<    "Parameters", see Section 4.2.  At the time of this writing, the
---
>    Parameters, see Section 4.2.  At the time of this writing, the
1191c1202
<    more significant part of the run as well as adjusting the "run_index"
---
>    more significant part of the run as well as adjusting the run_index
1194c1205
<    part of the run as it is.  The "run_index" is reset to zero for each
---
>    part of the run as it is.  The run_index is reset to zero for each
1225c1236
<    The "log2_run" array is also used within [ISO.14495-1.1999].
---
>    The log2_run array is also used within [ISO.14495-1.1999].
1229c1240
<    "sign_extend" is the function of increasing the number of bits of an
---
>    sign_extend is the function of increasing the number of bits of an
1248c1259
<    and a per context value for "k".
---
>    and a per context value for k.
1307c1318
<    When "keyframe" (see Section 4.4) value is 1, all VLC coder state
---
>    When keyframe (see Section 4.4) value is 1, all VLC coder state
1318c1329
<    (when required) a "Configuration Record".
---
>    (when required) a Configuration Record.
1349c1360
<    "frame_pixel_width" is defined as Frame width in pixels.
---
>    frame_pixel_width is defined as Frame width in pixels.
1351c1362
<    "frame_pixel_height" is defined as Frame height in pixels.
---
>    frame_pixel_height is defined as Frame height in pixels.
1355c1366
<    "ConfigurationRecordIsPresent" is set to 0.
---
>    ConfigurationRecordIsPresent is set to 0.
1362c1373
<    (represented as "len - 1" in the pseudocode below) using the method
---
>    (represented as len - 1 in the pseudocode below) using the method
1364,1366c1375,1377
<    stored as it is identical to the first with flipped sign. "scale" and
<    "len_count[ i ][ j ]" are temporary values used for the computing of
<    "context_count[ i ]" and are not used outside Quantization Table Set
---
>    stored as it is identical to the first with flipped sign. scale and
>    len_count[ i ][ j ] are temporary values used for the computing of
>    context_count[ i ] and are not used outside Quantization Table Set
1375c1386
<    "QuantizationTableSet" has its own initial states, all set to 128.
---
>    QuantizationTableSet has its own initial states, all set to 128.
1388c1399
<    "MAX_CONTEXT_INPUTS" is 5.
---
>    MAX_CONTEXT_INPUTS is 5.
1411c1422
< 4.1.1.  "quant_tables"
---
> 4.1.1.  quant_tables
1413,1415c1424,1426
<    "quant_tables[ i ][ j ][ k ]" indicates the Quantization Table value
<    of the Quantized Sample Difference "k" of the Quantization Table "j"
<    of the Quantization Table Set "i".
---
>    quant_tables[ i ][ j ][ k ] indicates the Quantization Table value of
>    the Quantized Sample Difference k of the Quantization Table j of the
>    Quantization Table Set i.
1417c1428
< 4.1.2.  "context_count"
---
> 4.1.2.  context_count
1419,1421c1430,1431
<    "context_count[ i ]" indicates the count of contexts for Quantization
<    Table Set "i". "context_count[ i ]" MUST be less than or equal to
<    32768.
---
>    context_count[ i ] indicates the count of contexts for Quantization
>    Table Set i. context_count[ i ] MUST be less than or equal to 32768.
1425c1435
<    The "Parameters" section, which could be in a global header of a
---
>    The Parameters section, which could be in a global header of a
1433c1443
<    "Parameters" has its own initial states, all set to 128.
---
>    Parameters has its own initial states, all set to 128.
1484c1494
< 4.2.1.  "version"
---
> 4.2.1.  version
1486c1496
<    "version" specifies the version of the FFV1 bitstream.
---
>    version specifies the version of the FFV1 bitstream.
1491,1492c1501,1502
<    Decoders SHOULD reject FFV1 bitstreams with "version <= 1 &&
<    ConfigurationRecordIsPresent == 1".
---
>    Decoders SHOULD reject FFV1 bitstreams with version <= 1 &&
>    ConfigurationRecordIsPresent == 1.
1494,1495c1504,1505
<    Decoders SHOULD reject FFV1 bitstreams with "version >= 3 &&
<    ConfigurationRecordIsPresent == 0".
---
>    Decoders SHOULD reject FFV1 bitstreams with version >= 3 &&
>    ConfigurationRecordIsPresent == 0.
1512c1522
<                              "version" values.
---
>                               version values.
1516c1526
< 4.2.2.  "micro_version"
---
> 4.2.2.  micro_version
1518c1528
<    "micro_version" specifies the micro-version of the FFV1 bitstream.
---
>    micro_version specifies the micro-version of the FFV1 bitstream.
1527c1537
<    Meaning of "micro_version" for "version" 3:
---
>    Meaning of micro_version for version 3:
1540c1550
<                       "micro_version" values for FFV1
---
>                        micro_version values for FFV1
1545c1555
< 4.2.3.  "coder_type"
---
> 4.2.3.  coder_type
1547c1557
<    "coder_type" specifies the coder used.
---
>    coder_type specifies the coder used.
1561c1571
<              Table 7: The definitions for "coder_type" values.
---
>               Table 7: The definitions for coder_type values.
1565c1575
<    If "coder_type" is 0, then "bits_per_raw_sample" SHOULD NOT be > 8.
---
>    If coder_type is 0, then bits_per_raw_sample SHOULD NOT be > 8.
1569c1579
<    with "bits_per_raw_sample" greater than eight, and range coder is
---
>    with bits_per_raw_sample greater than eight, and range coder is
1572c1582
< 4.2.4.  "state_transition_delta"
---
> 4.2.4.  state_transition_delta
1574c1584
<    "state_transition_delta" specifies the range coder custom state
---
>    state_transition_delta specifies the range coder custom state
1577c1587
<    If "state_transition_delta" is not present in the FFV1 bitstream, all
---
>    If state_transition_delta is not present in the FFV1 bitstream, all
1581c1591
< 4.2.5.  "colorspace_type"
---
> 4.2.5.  colorspace_type
1583c1593
<    "colorspace_type" specifies the color space encoded, the pixel
---
>    colorspace_type specifies the color space encoded, the pixel
1602c1612
<            Table 8: The definitions for "colorspace_type" values.
---
>             Table 8: The definitions for colorspace_type values.
1604,1606c1614,1616
<    FFV1 bitstreams with "colorspace_type == 1 && (chroma_planes != 1 ||
<    log2_h_chroma_subsample != 0 || log2_v_chroma_subsample != 0)" are
<    not part of this specification.
---
>    FFV1 bitstreams with colorspace_type == 1 && (chroma_planes != 1 ||
>    log2_h_chroma_subsample != 0 || log2_v_chroma_subsample != 0) are not
>    part of this specification.
1608c1618
< 4.2.6.  "chroma_planes"
---
> 4.2.6.  chroma_planes
1610c1620
<    "chroma_planes" indicates if chroma (color) Planes are present.
---
>    chroma_planes indicates if chroma (color) Planes are present.
1621c1631
<                           "chroma_planes" values.
---
>                            chroma_planes values.
1623c1633
< 4.2.7.  "bits_per_raw_sample"
---
> 4.2.7.  bits_per_raw_sample
1625c1635
<    "bits_per_raw_sample" indicates the number of bits for each Sample.
---
>    bits_per_raw_sample indicates the number of bits for each Sample.
1637c1647
<                        "bits_per_raw_sample" values.
---
>                         bits_per_raw_sample values.
1639,1640c1649,1650
<    * Encoders MUST NOT store "bits_per_raw_sample = 0".  Decoders SHOULD
<    accept and interpret "bits_per_raw_sample = 0" as 8.
---
>    * Encoders MUST NOT store bits_per_raw_sample = 0.  Decoders SHOULD
>    accept and interpret bits_per_raw_sample = 0 as 8.
1642c1652
< 4.2.8.  "log2_h_chroma_subsample"
---
> 4.2.8.  log2_h_chroma_subsample
1644c1654
<    "log2_h_chroma_subsample" indicates the subsample factor, stored in
---
>    log2_h_chroma_subsample indicates the subsample factor, stored in
1646c1656
<    ("chroma_width = 2 ^ -log2_h_chroma_subsample * luma_width").
---
>    (chroma_width = 2 ^ -log2_h_chroma_subsample * luma_width).
1648c1658
< 4.2.9.  "log2_v_chroma_subsample"
---
> 4.2.9.  log2_v_chroma_subsample
1650c1660
<    "log2_v_chroma_subsample" indicates the subsample factor, stored in
---
>    log2_v_chroma_subsample indicates the subsample factor, stored in
1652,1653c1662
<    height ("chroma_height = 2 ^ -log2_v_chroma_subsample *
<    luma_height").
---
>    height (chroma_height = 2 ^ -log2_v_chroma_subsample * luma_height).
1655c1664
< 4.2.10.  "extra_plane"
---
> 4.2.10.  extra_plane
1657c1666
<    "extra_plane" indicates if an extra Plane is present.
---
>    extra_plane indicates if an extra Plane is present.
1668c1677
<                           "extra_plane" values.
---
>                            extra_plane values.
1670c1679
< 4.2.11.  "num_h_slices"
---
> 4.2.11.  num_h_slices
1672,1673c1681,1682
<    "num_h_slices" indicates the number of horizontal elements of the
<    Slice raster.
---
>    num_h_slices indicates the number of horizontal elements of the Slice
>    raster.
1677c1686
< 4.2.12.  "num_v_slices"
---
> 4.2.12.  num_v_slices
1679c1688
<    "num_v_slices" indicates the number of vertical elements of the Slice
---
>    num_v_slices indicates the number of vertical elements of the Slice
1684c1693
< 4.2.13.  "quant_table_set_count"
---
> 4.2.13.  quant_table_set_count
1686,1687c1695,1696
<    "quant_table_set_count" indicates the number of Quantization
<    Table Sets. "quant_table_set_count" MUST be less than or equal to 8.
---
>    quant_table_set_count indicates the number of Quantization
>    Table Sets. quant_table_set_count MUST be less than or equal to 8.
1693c1702
< 4.2.14.  "states_coded"
---
> 4.2.14.  states_coded
1695c1704
<    "states_coded" indicates if the respective Quantization Table Set has
---
>    states_coded indicates if the respective Quantization Table Set has
1710c1719
<                           "states_coded" values.
---
>                            states_coded values.
1712c1721
< 4.2.15.  "initial_state_delta"
---
> 4.2.15.  initial_state_delta
1714,1716c1723,1725
<    "initial_state_delta[ i ][ j ][ k ]" indicates the initial range
<    coder state, and it is encoded using "k" as context index for the
<    range coder and the following pseudocode:
---
>    initial_state_delta[ i ][ j ][ k ] indicates the initial range coder
>    state, and it is encoded using k as context index for the range coder
>    and the following pseudocode:
1720,1721c1729,1730
<                 Figure 29: Predictor value for the coding of
<                    "initial_state_delta[ i ][ j ][ k ]".
---
>      Figure 29: Predictor value for the coding of initial_state_delta[
>                                i ][ j ][ k ].
1727c1736
<                    "initial_state_delta[ i ][ j ][ k ]".
---
>                     initial_state_delta[ i ][ j ][ k ].
1729c1738
< 4.2.16.  "ec"
---
> 4.2.16.  ec
1731c1740
<    "ec" indicates the error detection/correction type.
---
>    ec indicates the error detection/correction type.
1733c1742
<         +=======+=================================================+
---
>           +=======+=============================================+
1735,1739c1744,1748
<         +=======+=================================================+
<         | 0     | 32-bit CRC in "ConfigurationRecord"             |
<         +-------+-------------------------------------------------+
<         | 1     | 32-bit CRC in "Slice" and "ConfigurationRecord" |
<         +-------+-------------------------------------------------+
---
>           +=======+=============================================+
>           | 0     | 32-bit CRC in ConfigurationRecord           |
>           +-------+---------------------------------------------+
>           | 1     | 32-bit CRC in Slice and ConfigurationRecord |
>           +-------+---------------------------------------------+
1741c1750
<         +-------+-------------------------------------------------+
---
>           +-------+---------------------------------------------+
1743c1752
<                  Table 13: The definitions for "ec" values.
---
>                   Table 13: The definitions for ec values.
1745c1754
< 4.2.17.  "intra"
---
> 4.2.17.  intra
1747,1748c1756
<    "intra" indicates the constraint on "keyframe" in each instance of
<    Frame.
---
>    intra indicates the constraint on keyframe in each instance of Frame.
1752c1760
<      +=======+=======================================================+
---
>       +=======+=====================================================+
1754,1758c1762,1766
<      +=======+=======================================================+
<      | 0     | "keyframe" can be 0 or 1 (non keyframes or keyframes) |
<      +-------+-------------------------------------------------------+
<      | 1     | "keyframe" MUST be 1 (keyframes only)                 |
<      +-------+-------------------------------------------------------+
---
>       +=======+=====================================================+
>       | 0     | keyframe can be 0 or 1 (non keyframes or keyframes) |
>       +-------+-----------------------------------------------------+
>       | 1     | keyframe MUST be 1 (keyframes only)                 |
>       +-------+-----------------------------------------------------+
1760c1768
<      +-------+-------------------------------------------------------+
---
>       +-------+-----------------------------------------------------+
1762c1770
<                Table 14: The definitions for "intra" values.
---
>                 Table 14: The definitions for intra values.
1766,1770c1774,1778
<    In the case of a FFV1 bitstream with "version >= 3", a "Configuration
<    Record" is stored in the underlying container as described in
<    Section 4.3.3.  It contains the "Parameters" used for all instances
<    of Frame.  The size of the "Configuration Record", "NumBytes", is
<    supplied by the underlying container.
---
>    In the case of a FFV1 bitstream with version >= 3, a Configuration
>    Record is stored in the underlying container as described in
>    Section 4.3.3.  It contains the Parameters used for all instances of
>    Frame.  The size of the Configuration Record, NumBytes, is supplied
>    by the underlying container.
1783c1791
< 4.3.1.  "reserved_for_future_use"
---
> 4.3.1.  reserved_for_future_use
1785c1793
<    "reserved_for_future_use" is a placeholder for future updates of this
---
>    reserved_for_future_use is a placeholder for future updates of this
1789c1797
<    write "reserved_for_future_use".
---
>    write reserved_for_future_use.
1792c1800
<    ignore "reserved_for_future_use".
---
>    ignore reserved_for_future_use.
1794c1802
< 4.3.2.  "configuration_record_crc_parity"
---
> 4.3.2.  configuration_record_crc_parity
1796,1797c1804,1805
<    "configuration_record_crc_parity" is 32 bits that are chosen so that
<    the "Configuration Record" as a whole has a CRC remainder of zero.
---
>    configuration_record_crc_parity is 32 bits that are chosen so that
>    the Configuration Record as a whole has a CRC remainder of zero.
1805,1809c1813,1817
<    This "Configuration Record" can be placed in any file format that
<    supports "Configuration Records", fitting as much as possible with
<    how the file format stores "Configuration Records".  The
<    "Configuration Record" storage place and "NumBytes" are currently
<    defined and supported for the following formats:
---
>    This Configuration Record can be placed in any file format that
>    supports Configuration Records, fitting as much as possible with how
>    the file format stores Configuration Records.  The Configuration
>    Record storage place and NumBytes are currently defined and supported
>    for the following formats:
1813,1814c1821,1822
<    The "Configuration Record" extends the stream format chunk ("AVI ",
<    "hdlr", "strl", "strf") with the "ConfigurationRecord" bitstream.
---
>    The Configuration Record extends the stream format chunk ("AVI ",
>    "hdlr", "strl", "strf") with the ConfigurationRecord bitstream.
1818c1826
<    "NumBytes" is defined as the size, in bytes, of the "strf" chunk
---
>    NumBytes is defined as the size, in bytes, of the "strf" chunk
1824,1827c1832,1835
<    The "Configuration Record" extends the sample description box
<    ("moov", "trak", "mdia", "minf", "stbl", "stsd") with a "glbl" box
<    that contains the "ConfigurationRecord" bitstream.  See
<    [ISO.14496-12.2020] for more information about boxes.
---
>    The Configuration Record extends the sample description box ("moov",
>    "trak", "mdia", "minf", "stbl", "stsd") with a "glbl" box that
>    contains the ConfigurationRecord bitstream.  See [ISO.14496-12.2020]
>    for more information about boxes.
1829c1837
<    "NumBytes" is defined as the size, in bytes, of the "glbl" box
---
>    NumBytes is defined as the size, in bytes, of the "glbl" box
1834,1840c1842,1847
<    The "codec_specific_data" element (in "stream_header" packet)
<    contains the "ConfigurationRecord" bitstream.  See [NUT] for more
<    information about elements.
< 
<    "NumBytes" is defined as the size, in bytes, of the
<    "codec_specific_data" element as indicated in the "length" field of
<    "codec_specific_data".
---
>    The codec_specific_data element (in stream_header packet) contains
>    the ConfigurationRecord bitstream.  See [NUT] for more information
>    about elements.
> 
>    NumBytes is defined as the size, in bytes, of the codec_specific_data
>    element as indicated in the "length" field of codec_specific_data.
1844,1848c1851,1855
<    FFV1 SHOULD use "V_FFV1" as the Matroska "Codec ID".  For FFV1
<    versions 2 or less, the Matroska "CodecPrivate" Element SHOULD NOT be
<    used.  For FFV1 versions 3 or greater, the Matroska "CodecPrivate"
<    Element MUST contain the FFV1 "Configuration Record" structure and no
<    other data.  See [Matroska] for more information about elements.
---
>    FFV1 SHOULD use V_FFV1 as the Matroska Codec ID.  For FFV1 versions 2
>    or less, the Matroska CodecPrivate Element SHOULD NOT be used.  For
>    FFV1 versions 3 or greater, the Matroska CodecPrivate Element MUST
>    contain the FFV1 Configuration Record structure and no other data.
>    See [Matroska] for more information about elements.
1850,1851c1857,1858
<    "NumBytes" is defined as the "Element Data Size" of the
<    "CodecPrivate" Element.
---
>    NumBytes is defined as the Element Data Size of the CodecPrivate
>    Element.
1855,1856c1862,1863
<    A "Frame" is an encoded representation of a complete static image.
<    The whole "Frame" is provided by the underlying container.
---
>    A Frame is an encoded representation of a complete static image.  The
>    whole Frame is provided by the underlying container.
1858,1860c1865,1867
<    A "Frame" consists of the "keyframe" field, "Parameters" (if "version
<    <= 1"), and a sequence of independent Slices.  The pseudocode below
<    describes the contents of a "Frame".
---
>    A Frame consists of the keyframe field, Parameters (if version <= 1),
>    and a sequence of independent Slices.  The pseudocode below describes
>    the contents of a Frame.
1862c1869
<    The "keyframe" field has its own initial state, set to 128.
---
>    The keyframe field has its own initial state, set to 128.
1908c1915
<    A "Slice" is an independent, spatial subsection of a Frame that is
---
>    A Slice is an independent, spatial subsection of a Frame that is
1910c1917
<    more than one "Slice" per Frame provides opportunities for taking
---
>    more than one Slice per Frame provides opportunities for taking
1913,1915c1920,1922
<    A "Slice" consists of a "Slice Header" (when relevant), a "Slice
<    Content", and a "Slice Footer" (when relevant).  The pseudocode below
<    describes the contents of a "Slice".
---
>    A Slice consists of a Slice Header (when relevant), a Slice Content,
>    and a Slice Footer (when relevant).  The pseudocode below describes
>    the contents of a Slice.
1939,1940c1946,1947
<    "padding" specifies a bit without any significance and used only for
<    byte alignment. "padding" MUST be 0.
---
>    padding specifies a bit without any significance and used only for
>    byte alignment. padding MUST be 0.
1942c1949
<    "reserved" specifies a bit without any significance in this
---
>    reserved specifies a bit without any significance in this
1946c1953
<    Encoders SHOULD NOT fill "reserved".
---
>    Encoders SHOULD NOT fill reserved.
1948c1955
<    Decoders SHOULD ignore "reserved".
---
>    Decoders SHOULD ignore reserved.
1952,1955c1959,1961
<    A "Slice Header" provides information about the decoding
<    configuration of the "Slice", such as its spatial position, size, and
<    aspect ratio.  The pseudocode below describes the contents of the
<    "Slice Header".
---
>    A Slice Header provides information about the decoding configuration
>    of the Slice, such as its spatial position, size, and aspect ratio.
>    The pseudocode below describes the contents of the Slice Header.
1957c1963
<    "Slice Header" has its own initial states, all set to 128.
---
>    Slice Header has its own initial states, all set to 128.
1974c1980
< 4.6.1.  "slice_x"
---
> 4.6.1.  slice_x
1976,1977c1982,1983
<    "slice_x" indicates the x position on the Slice raster formed by
<    "num_h_slices".
---
>    slice_x indicates the x position on the Slice raster formed by
>    num_h_slices.
1981c1987
< 4.6.2.  "slice_y"
---
> 4.6.2.  slice_y
1983,1984c1989,1990
<    "slice_y" indicates the y position on the Slice raster formed by
<    "num_v_slices".
---
>    slice_y indicates the y position on the Slice raster formed by
>    num_v_slices.
1988c1994
< 4.6.3.  "slice_width"
---
> 4.6.3.  slice_width
1990,1991c1996,1997
<    "slice_width" indicates the width on the Slice raster formed by
<    "num_h_slices".
---
>    slice_width indicates the width on the Slice raster formed by
>    num_h_slices.
1995c2001
< 4.6.4.  "slice_height"
---
> 4.6.4.  slice_height
1997,1998c2003,2004
<    "slice_height" indicates the height on the Slice raster formed by
<    "num_v_slices".
---
>    slice_height indicates the height on the Slice raster formed by
>    num_v_slices.
2002c2008
< 4.6.5.  "quant_table_set_index_count"
---
> 4.6.5.  quant_table_set_index_count
2004c2010
<    "quant_table_set_index_count" is defined as the following:
---
>    quant_table_set_index_count is defined as the following:
2009c2015
< 4.6.6.  "quant_table_set_index"
---
> 4.6.6.  quant_table_set_index
2011c2017
<    "quant_table_set_index" indicates the Quantization Table Set index to
---
>    quant_table_set_index indicates the Quantization Table Set index to
2013c2019
<    "Slice Content".
---
>    Slice Content.
2017c2023
< 4.6.7.  "picture_structure"
---
> 4.6.7.  picture_structure
2019,2020c2025,2026
<    "picture_structure" specifies the temporal and spatial relationship
<    of each Line of the Frame.
---
>    picture_structure specifies the temporal and spatial relationship of
>    each Line of the Frame.
2039c2045
<                         "picture_structure" values.
---
>                          picture_structure values.
2041c2047
< 4.6.8.  "sar_num"
---
> 4.6.8.  sar_num
2043c2049
<    "sar_num" specifies the Sample aspect ratio numerator.
---
>    sar_num specifies the Sample aspect ratio numerator.
2051,2052c2057,2058
<    If "sar_den" is 0, decoders SHOULD ignore the encoded value and
<    consider that "sar_num" is 0.
---
>    If sar_den is 0, decoders SHOULD ignore the encoded value and
>    consider that sar_num is 0.
2054c2060
< 4.6.9.  "sar_den"
---
> 4.6.9.  sar_den
2056c2062
<    "sar_den" specifies the Sample aspect ratio denominator.
---
>    sar_den specifies the Sample aspect ratio denominator.
2064,2065c2070,2071
<    If "sar_num" is 0, decoders SHOULD ignore the encoded value and
<    consider that "sar_den" is 0.
---
>    If sar_num is 0, decoders SHOULD ignore the encoded value and
>    consider that sar_den is 0.
2069c2075
<    A "Slice Content" contains all Line elements part of the "Slice".
---
>    A Slice Content contains all Line elements part of the Slice.
2092c2098
< 4.7.1.  "primary_color_count"
---
> 4.7.1.  primary_color_count
2094c2100
<    "primary_color_count" is defined as the following:
---
>    primary_color_count is defined as the following:
2098c2104
< 4.7.2.  "plane_pixel_height"
---
> 4.7.2.  plane_pixel_height
2100,2101c2106,2107
<    "plane_pixel_height[ p ]" is the height in pixels of Plane p of the
<    "Slice".  It is defined as the following:
---
>    plane_pixel_height[ p ] is the height in pixels of Plane p of the
>    Slice.  It is defined as the following:
2107c2113
< 4.7.3.  "slice_pixel_height"
---
> 4.7.3.  slice_pixel_height
2109c2115
<    "slice_pixel_height" is the height in pixels of the Slice.  It is
---
>    slice_pixel_height is the height in pixels of the Slice.  It is
2118c2124
< 4.7.4.  "slice_pixel_y"
---
> 4.7.4.  slice_pixel_y
2120c2126
<    "slice_pixel_y" is the Slice vertical position in pixels.  It is
---
>    slice_pixel_y is the Slice vertical position in pixels.  It is
2127c2133
<    A "Line" is a list of the Sample Differences (relative to the
---
>    A Line is a list of the Sample Differences (relative to the
2129c2135
<    describes the contents of the "Line".
---
>    describes the contents of the Line.
2145c2151
< 4.8.1.  "plane_pixel_width"
---
> 4.8.1.  plane_pixel_width
2147,2148c2153,2154
<    "plane_pixel_width[ p ]" is the width in pixels of Plane p of the
<    "Slice".  It is defined as the following:
---
>    plane_pixel_width[ p ] is the width in pixels of Plane p of the
>    Slice.  It is defined as the following:
2154c2160
< 4.8.2.  "slice_pixel_width"
---
> 4.8.2.  slice_pixel_width
2156,2157c2162,2163
<    "slice_pixel_width" is the width in pixels of the Slice.  It is
<    defined as the following:
---
>    slice_pixel_width is the width in pixels of the Slice.  It is defined
>    as the following:
2165c2171
< 4.8.3.  "slice_pixel_x"
---
> 4.8.3.  slice_pixel_x
2167c2173
<    "slice_pixel_x" is the Slice horizontal position in pixels.  It is
---
>    slice_pixel_x is the Slice horizontal position in pixels.  It is
2172c2178
< 4.8.4.  "sample_difference"
---
> 4.8.4.  sample_difference
2174,2176c2180,2182
<    "sample_difference[ p ][ y ][ x ]" is the Sample Difference for
<    Sample at Plane "p", y position "y", and x position "x".  The Sample
<    value is computed based on median predictor and context described in
---
>    sample_difference[ p ][ y ][ x ] is the Sample Difference for Sample
>    at Plane p, y position y, and x position x.  The Sample value is
>    computed based on median predictor and context described in
2181,2183c2187,2189
<    A "Slice Footer" provides information about Slice size and
<    (optionally) parity.  The pseudocode below describes the contents of
<    the "Slice Footer".
---
>    A Slice Footer provides information about Slice size and (optionally)
>    parity.  The pseudocode below describes the contents of the Slice
>    Footer.
2185c2191
<    Note: "Slice Footer" is always byte aligned.
---
>    Note: Slice Footer is always byte aligned.
2197c2203
< 4.9.1.  "slice_size"
---
> 4.9.1.  slice_size
2199c2205
<    "slice_size" indicates the size of the Slice in bytes.
---
>    slice_size indicates the size of the Slice in bytes.
2205c2211
< 4.9.2.  "error_status"
---
> 4.9.2.  error_status
2207c2213
<    "error_status" specifies the error status.
---
>    error_status specifies the error status.
2221c2227
<                 Table 16: The definitions for "error_status"
---
>                  Table 16: The definitions for error_status
2224c2230
< 4.9.3.  "slice_crc_parity"
---
> 4.9.3.  slice_crc_parity
2226c2232
<    "slice_crc_parity" is 32 bits that are chosen so that the Slice as a
---
>    slice_crc_parity is 32 bits that are chosen so that the Slice as a
2238,2240c2244,2246
<    version 3 and if "frame_pixel_width * frame_pixel_height" is more
<    than 101376, "slice_width * slice_height" MUST be less or equal to
<    "num_h_slices * num_v_slices / 4".  Note: 101376 is the frame size in
---
>    version 3 and if frame_pixel_width * frame_pixel_height is more than
>    101376, slice_width * slice_height MUST be less or equal to
>    num_h_slices * num_v_slices / 4.  Note: 101376 is the frame size in
2248,2250c2254,2256
<    For each Frame with a "keyframe" value of 0, each Slice MUST have the
<    same value of "slice_x", "slice_y", "slice_width", and "slice_height"
<    as a Slice in the previous Frame.
---
>    For each Frame with a keyframe value of 0, each Slice MUST have the
>    same value of slice_x, slice_y, slice_width, and slice_height as a
>    Slice in the previous Frame.
2271,2276c2277,2282
<    example is allocating "frame_pixel_width * frame_pixel_height" in
<    pixel count computations without considering that the multiplication
<    result may have overflowed the range of the arithmetic type.  The
<    range coder could, if implemented naively, read one byte over the
<    end.  The implementation MUST ensure that no read outside allocated
<    and initialized memory occurs.
---
>    example is allocating frame_pixel_width * frame_pixel_height in pixel
>    count computations without considering that the multiplication result
>    may have overflowed the range of the arithmetic type.  The range
>    coder could, if implemented naively, read one byte over the end.  The
>    implementation MUST ensure that no read outside allocated and
>    initialized memory occurs.
2299c2305
<       "version":  The "version" of the FFV1 encoding as defined by
---
>       version:  The version of the FFV1 encoding as defined by
2302,2303c2308,2309
<       "micro_version":  The "micro_version" of the FFV1 encoding as
<          defined by Section 4.2.2.
---
>       micro_version:  The micro_version of the FFV1 encoding as defined
>          by Section 4.2.2.
2305c2311
<       "coder_type":  The "coder_type" of the FFV1 encoding as defined by
---
>       coder_type:  The coder_type of the FFV1 encoding as defined by
2308c2314
<       "colorspace_type":  The "colorspace_type" of the FFV1 encoding as
---
>       colorspace_type:  The colorspace_type of the FFV1 encoding as
2311,2312c2317,2318
<       "bits_per_raw_sample":  The "bits_per_raw_sample" of the FFV1
<          encoding as defined by Section 4.2.7.
---
>       bits_per_raw_sample:  The bits_per_raw_sample of the FFV1 encoding
>          as defined by Section 4.2.7.
2314,2316c2320,2321
<       "max_slices":  The value of "max_slices" is an integer indicating
<          the maximum count of Slices within a Frame of the FFV1
<          encoding.
---
>       max_slices:  The value of max_slices is an integer indicating the
>          maximum count of Slices within a Frame of the FFV1 encoding.
2318,2321c2323,2327
<    Encoding considerations:  This media type is defined for
<       encapsulation in several audiovisual container formats and
<       contains binary data; see Section 4.3.3.  This media type is
<       framed binary data; see Section 4.8 of [RFC6838].
---
>    Encoding considerations:
>       This media type is defined for encapsulation in several
>       audiovisual container formats and contains binary data; see
>       Section 4.3.3.  This media type is framed binary data; see
>       Section 4.8 of [RFC6838].
2329,2332c2335,2339
<    Applications that use this media type:  Any application that requires
<       the transport of lossless video can use this media type.  Some
<       examples are, but not limited to, screen recording, scientific
<       imaging, and digital video preservation.
---
>    Applications that use this media type:
>       Any application that requires the transport of lossless video can
>       use this media type.  Some examples are, but not limited to,
>       screen recording, scientific imaging, and digital video
>       preservation.
2477c2484
<    each Slice.  Each Slice footer contains a "slice_size" field so the
---
>    each Slice.  Each Slice footer contains a slice_size field so the
2483,2490c2490,2496
<    After having checked the "keyframe" field, a decoder should parse
<    "slice_size" fields, from "slice_size" of the last Slice at the end
<    of the "Frame" up to "slice_size" of the first Slice at the beginning
<    of the "Frame" before parsing Slices, in order to have Slice
<    boundaries.  A decoder may fall back on sequential order e.g., in
<    case of a corrupted "Frame" (e.g., frame size unknown or "slice_size"
<    of Slices not coherent) or if there is no possibility of seeking into
<    the stream.
---
>    After having checked the keyframe field, a decoder should parse
>    slice_size fields, from slice_size of the last Slice at the end of
>    the Frame up to slice_size of the first Slice at the beginning of the
>    Frame before parsing Slices, in order to have Slice boundaries.  A
>    decoder may fall back on sequential order e.g., in case of a
>    corrupted Frame (e.g., frame size unknown or slice_size of Slices not
>    coherent) or if there is no possibility of seeking into the stream.
2498,2503c2504,2508
<    "error_status" and "slice_crc_parity" in the "reserved" bits of
<    "Slice".  Any revision of this specification should avoid adding 40
<    bits of content after "SliceContent" if "version == 0" or "version ==
<    1", otherwise a decoder conforming to the revised specification could
<    not distinguish between a revised bitstream and such buggy bitstream
<    in the wild.
---
>    error_status and slice_crc_parity in the reserved bits of Slice.  Any
>    revision of this specification should avoid adding 40 bits of content
>    after SliceContent if version == 0 or version == 1, otherwise a
>    decoder conforming to the revised specification could not distinguish
>    between a revised bitstream and such buggy bitstream in the wild.
2551d2555
< 
2556d2559
< 
2561d2563
< 
