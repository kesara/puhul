14c14
< <meta content="xml2rfc 3.14.0" name="generator">
---
> <meta content="xml2rfc 3.18.2" name="generator">
22,27c22,25
<   xml2rfc 3.14.0
<     Python 3.9.13
<     appdirs 1.4.4
<     ConfigArgParse 1.5.3
<     google-i18n-address 2.5.1
<     html5lib 1.1
---
>   xml2rfc 3.18.2
>     Python 3.11.6
>     ConfigArgParse 1.7
>     google-i18n-address 3.1.0
30,32c28,29
<     kitchen 1.2.6
<     lxml 4.9.0
<     MarkupSafe 2.1.1
---
>     lxml 4.9.3
>     platformdirs 4.0.0
34,36c31,33
<     PyYAML 6.0
<     requests 2.28.0
<     setuptools 44.1.1
---
>     PyYAML 6.0.1
>     requests 2.31.0
>     setuptools 65.5.0
38c35
<     weasyprint 56.1
---
>     wcwidth 0.2.12
40c37
< <link href="rfc9273.xml" rel="alternate" type="application/rfc+xml">
---
> <link href="rfc/rfc9273.xml" rel="alternate" type="application/rfc+xml">
50c47
<   commented changes found necssary during the development of the v3
---
>   commented changes found necessary during the development of the v3
59a57,62
> :root {
>   --font-sans: 'Noto Sans', Arial, Helvetica, sans-serif;
>   --font-serif: 'Noto Serif', 'Times', 'Times New Roman', serif;
>   --font-mono: 'Roboto Mono', Courier, 'Courier New', monospace;
> }
> 
62d64
<   width: extend-to-zoom;
77c79
<   font-family: 'Noto Sans', Arial, Helvetica, sans-serif;
---
>   font-family: var(--font-sans);
79a82
>   overflow-wrap: break-word;
165a169,177
> svg[font-family~="serif" i], svg [font-family~="serif" i] {
>   font-family: var(--font-serif);
> }
> svg[font-family~="sans-serif" i], svg [font-family~="sans-serif" i] {
>   font-family: var(--font-sans);
> }
> svg[font-family~="monospace" i], svg [font-family~="monospace" i] {
>   font-family: var(--font-mono);
> }
179a192
>   display: table;
248c261,262
< a[href].selfRef {
---
> a[href].selfRef,
> .iref + a[href].internal {
258c272
< tt, code, pre, code {
---
> tt, code, pre {
260c274
<   font-family: 'Roboto Mono', monospace;
---
>   font-family: var(--font-mono);
299a314,316
> blockquote > *:last-child {
>   margin-bottom: 0;
> }
497c514
<   font-family: "Noto Sans",Arial,Helvetica,sans-serif;
---
>   font-family: var(--font-sans);
637d653
< 
660c676
<   pre.breakable {
---
>   .breakable pre {
730c746
<   /* The follwing is commented out here, but set appropriately by in code, as
---
>   /* The following is commented out here, but set appropriately by in code, as
830c846
< tt, code, pre, code {
---
> tt, code, pre {
835c851
< pre.sourcecode,
---
> .sourcecode pre,
871c887
< /* Make the alternative author contact informatio look less like just another
---
> /* Make the alternative author contact information look less like just another
1052a1069
>   .artwork > pre,
1067c1084
< and increase the contrast between border and odd row background sligthtly */
---
> and increase the contrast between border and odd row background slightly */
1073a1091,1093
> tr {
>   break-inside: avoid;
> }
1124c1144
< /* Text in compact lists should not get extra bottim margin space,
---
> /* Text in compact lists should not get extra bottom margin space,
1149c1169
< /* Tweak the comact list text */
---
> /* Tweak the compact list text */
1167c1187
< dd > div:first-child > pre.sourcecode,
---
> dd > div.sourcecode:first-child,
1181c1201
< li > p:last-of-type {
---
> li > p:last-of-type:only-child {
1185a1206
> <link href="https://datatracker.ietf.org/doc/draft-irtf-nwcrg-nwc-ccn-reqs-09" rel="prev">
1188c1209
<   <link href="https://datatracker.ietf.org/doc/draft-irtf-nwcrg-nwc-ccn-reqs-09" rel="prev">
---
>   <script type="application/javascript">async function addMetadata(){try{const e=document.styleSheets[0].cssRules;for(let t=0;t<e.length;t++)if(/#identifiers/.exec(e[t].selectorText)){const a=e[t].cssText.replace("#identifiers","#external-updates");document.styleSheets[0].insertRule(a,document.styleSheets[0].cssRules.length)}}catch(e){console.log(e)}const e=document.getElementById("external-metadata");if(e)try{var t,a="",o=function(e){const t=document.getElementsByTagName("meta");for(let a=0;a<t.length;a++)if(t[a].getAttribute("name")===e)return t[a].getAttribute("content");return""}("rfc.number");if(o){t="https://www.rfc-editor.org/rfc/rfc"+o+".json";try{const e=await fetch(t);a=await e.json()}catch(e){t=document.URL.indexOf("html")>=0?document.URL.replace(/html$/,"json"):document.URL+".json";const o=await fetch(t);a=await o.json()}}if(!a)return;e.style.display="block";const s="",d="https://datatracker.ietf.org/doc",n="https://datatracker.ietf.org/ipr/search",c="https://www.rfc-editor.org/info",l=a.doc_id.toLowerCase(),i=a.doc_id.slice(0,3).toLowerCase(),f=a.doc_id.slice(3).replace(/^0+/,""),u={status:"Status",obsoletes:"Obsoletes",obsoleted_by:"Obsoleted By",updates:"Updates",updated_by:"Updated By",see_also:"See Also",errata_url:"Errata"};let h="<dl style='overflow:hidden' id='external-updates'>";["status","obsoletes","obsoleted_by","updates","updated_by","see_also","errata_url"].forEach(e=>{if("status"==e){a[e]=a[e].toLowerCase();var t=a[e].split(" "),o=t.length,w="",p=1;for(let e=0;e<o;e++)p<o?w=w+r(t[e])+" ":w+=r(t[e]),p++;a[e]=w}else if("obsoletes"==e||"obsoleted_by"==e||"updates"==e||"updated_by"==e){var g,m="",b=1;g=a[e].length;for(let t=0;t<g;t++)a[e][t]&&(a[e][t]=String(a[e][t]).toLowerCase(),m=b<g?m+"<a href='"+s+"/rfc/".concat(a[e][t])+"'>"+a[e][t].slice(3)+"</a>, ":m+"<a href='"+s+"/rfc/".concat(a[e][t])+"'>"+a[e][t].slice(3)+"</a>",b++);a[e]=m}else if("see_also"==e){var y,L="",C=1;y=a[e].length;for(let t=0;t<y;t++)if(a[e][t]){a[e][t]=String(a[e][t]);var _=a[e][t].slice(0,3),v=a[e][t].slice(3).replace(/^0+/,"");L=C<y?"RFC"!=_?L+"<a href='"+s+"/info/"+_.toLowerCase().concat(v.toLowerCase())+"'>"+_+" "+v+"</a>, ":L+"<a href='"+s+"/info/"+_.toLowerCase().concat(v.toLowerCase())+"'>"+v+"</a>, ":"RFC"!=_?L+"<a href='"+s+"/info/"+_.toLowerCase().concat(v.toLowerCase())+"'>"+_+" "+v+"</a>":L+"<a href='"+s+"/info/"+_.toLowerCase().concat(v.toLowerCase())+"'>"+v+"</a>",C++}a[e]=L}else if("errata_url"==e){var R="";R=a[e]?R+"<a href='"+a[e]+"'>Errata exist</a> | <a href='"+d+"/"+l+"'>Datatracker</a>| <a href='"+n+"/?"+i+"="+f+"&submit="+i+"'>IPR</a> | <a href='"+c+"/"+l+"'>Info page</a>":"<a href='"+d+"/"+l+"'>Datatracker</a> | <a href='"+n+"/?"+i+"="+f+"&submit="+i+"'>IPR</a> | <a href='"+c+"/"+l+"'>Info page</a>",a[e]=R}""!=a[e]?"Errata"==u[e]?h+=`<dt>More info:</dt><dd>${a[e]}</dd>`:h+=`<dt>${u[e]}:</dt><dd>${a[e]}</dd>`:"Errata"==u[e]&&(h+=`<dt>More info:</dt><dd>${a[e]}</dd>`)}),h+="</dl>",e.innerHTML=h}catch(e){console.log(e)}else console.log("Could not locate metadata <div> element");function r(e){return e.charAt(0).toUpperCase()+e.slice(1)}}window.removeEventListener("load",addMetadata),window.addEventListener("load",addMetadata);</script>
1190,1191c1211,1212
< <body>
< <script src="https://www.rfc-editor.org/js/metadata.min.js"></script>
---
> <body class="xml2rfc">
> <script src="metadata.min.js"></script>
1289c1310
<             <p id="section-toc.1-1.1.1" class="keepWithNext"><a href="#section-1" class="xref">1</a>.  <a href="#name-introduction" class="xref">Introduction</a></p>
---
>             <p id="section-toc.1-1.1.1" class="keepWithNext"><a href="#section-1" class="auto internal xref">1</a>.  <a href="#name-introduction" class="internal xref">Introduction</a></p>
1292c1313
<             <p id="section-toc.1-1.2.1"><a href="#section-2" class="xref">2</a>.  <a href="#name-terminology" class="xref">Terminology</a></p>
---
>             <p id="section-toc.1-1.2.1"><a href="#section-2" class="auto internal xref">2</a>.  <a href="#name-terminology" class="internal xref">Terminology</a></p>
1295c1316
<                 <p id="section-toc.1-1.2.2.1.1" class="keepWithNext"><a href="#section-2.1" class="xref">2.1</a>.  <a href="#name-definitions-related-to-nc" class="xref">Definitions Related to NC</a></p>
---
>                 <p id="section-toc.1-1.2.2.1.1" class="keepWithNext"><a href="#section-2.1" class="auto internal xref">2.1</a>.  <a href="#name-definitions-related-to-nc" class="internal xref">Definitions Related to NC</a></p>
1298c1319
<                 <p id="section-toc.1-1.2.2.2.1" class="keepWithNext"><a href="#section-2.2" class="xref">2.2</a>.  <a href="#name-definitions-related-to-ccnx" class="xref">Definitions Related to CCNx/NDN</a></p>
---
>                 <p id="section-toc.1-1.2.2.2.1" class="keepWithNext"><a href="#section-2.2" class="auto internal xref">2.2</a>.  <a href="#name-definitions-related-to-ccnx" class="internal xref">Definitions Related to CCNx/NDN</a></p>
1303c1324
<             <p id="section-toc.1-1.3.1"><a href="#section-3" class="xref">3</a>.  <a href="#name-ccnx-ndn-basics" class="xref">CCNx/NDN Basics</a></p>
---
>             <p id="section-toc.1-1.3.1"><a href="#section-3" class="auto internal xref">3</a>.  <a href="#name-ccnx-ndn-basics" class="internal xref">CCNx/NDN Basics</a></p>
1306c1327
<             <p id="section-toc.1-1.4.1"><a href="#section-4" class="xref">4</a>.  <a href="#name-nc-basics" class="xref">NC Basics</a></p>
---
>             <p id="section-toc.1-1.4.1"><a href="#section-4" class="auto internal xref">4</a>.  <a href="#name-nc-basics" class="internal xref">NC Basics</a></p>
1309c1330
<             <p id="section-toc.1-1.5.1"><a href="#section-5" class="xref">5</a>.  <a href="#name-advantages-of-nc-and-ccnx-n" class="xref">Advantages of NC and CCNx/NDN</a></p>
---
>             <p id="section-toc.1-1.5.1"><a href="#section-5" class="auto internal xref">5</a>.  <a href="#name-advantages-of-nc-and-ccnx-n" class="internal xref">Advantages of NC and CCNx/NDN</a></p>
1312c1333
<             <p id="section-toc.1-1.6.1"><a href="#section-6" class="xref">6</a>.  <a href="#name-technical-considerations" class="xref">Technical Considerations</a></p>
---
>             <p id="section-toc.1-1.6.1"><a href="#section-6" class="auto internal xref">6</a>.  <a href="#name-technical-considerations" class="internal xref">Technical Considerations</a></p>
1315c1336
<                 <p id="section-toc.1-1.6.2.1.1"><a href="#section-6.1" class="xref">6.1</a>.  <a href="#name-content-naming" class="xref">Content Naming</a></p>
---
>                 <p id="section-toc.1-1.6.2.1.1"><a href="#section-6.1" class="auto internal xref">6.1</a>.  <a href="#name-content-naming" class="internal xref">Content Naming</a></p>
1318c1339
<                     <p id="section-toc.1-1.6.2.1.2.1.1"><a href="#section-6.1.1" class="xref">6.1.1</a>.  <a href="#name-unique-naming-for-nc-packet" class="xref">Unique Naming for NC Packets</a></p>
---
>                     <p id="section-toc.1-1.6.2.1.2.1.1"><a href="#section-6.1.1" class="auto internal xref">6.1.1</a>.  <a href="#name-unique-naming-for-nc-packet" class="internal xref">Unique Naming for NC Packets</a></p>
1321c1342
<                     <p id="section-toc.1-1.6.2.1.2.2.1"><a href="#section-6.1.2" class="xref">6.1.2</a>.  <a href="#name-nonunique-naming-for-nc-pac" class="xref">Nonunique Naming for NC Packets</a></p>
---
>                     <p id="section-toc.1-1.6.2.1.2.2.1"><a href="#section-6.1.2" class="auto internal xref">6.1.2</a>.  <a href="#name-nonunique-naming-for-nc-pac" class="internal xref">Nonunique Naming for NC Packets</a></p>
1326c1347
<                 <p id="section-toc.1-1.6.2.2.1"><a href="#section-6.2" class="xref">6.2</a>.  <a href="#name-transport" class="xref">Transport</a></p>
---
>                 <p id="section-toc.1-1.6.2.2.1"><a href="#section-6.2" class="auto internal xref">6.2</a>.  <a href="#name-transport" class="internal xref">Transport</a></p>
1329c1350
<                     <p id="section-toc.1-1.6.2.2.2.1.1"><a href="#section-6.2.1" class="xref">6.2.1</a>.  <a href="#name-scope-of-nc" class="xref">Scope of NC</a></p>
---
>                     <p id="section-toc.1-1.6.2.2.2.1.1"><a href="#section-6.2.1" class="auto internal xref">6.2.1</a>.  <a href="#name-scope-of-nc" class="internal xref">Scope of NC</a></p>
1332c1353
<                     <p id="section-toc.1-1.6.2.2.2.2.1"><a href="#section-6.2.2" class="xref">6.2.2</a>.  <a href="#name-consumer-operation" class="xref">Consumer Operation</a></p>
---
>                     <p id="section-toc.1-1.6.2.2.2.2.1"><a href="#section-6.2.2" class="auto internal xref">6.2.2</a>.  <a href="#name-consumer-operation" class="internal xref">Consumer Operation</a></p>
1335c1356
<                     <p id="section-toc.1-1.6.2.2.2.3.1"><a href="#section-6.2.3" class="xref">6.2.3</a>.  <a href="#name-forwarder-operation" class="xref">Forwarder Operation</a></p>
---
>                     <p id="section-toc.1-1.6.2.2.2.3.1"><a href="#section-6.2.3" class="auto internal xref">6.2.3</a>.  <a href="#name-forwarder-operation" class="internal xref">Forwarder Operation</a></p>
1338c1359
<                     <p id="section-toc.1-1.6.2.2.2.4.1"><a href="#section-6.2.4" class="xref">6.2.4</a>.  <a href="#name-producer-operation" class="xref">Producer Operation</a></p>
---
>                     <p id="section-toc.1-1.6.2.2.2.4.1"><a href="#section-6.2.4" class="auto internal xref">6.2.4</a>.  <a href="#name-producer-operation" class="internal xref">Producer Operation</a></p>
1341c1362
<                     <p id="section-toc.1-1.6.2.2.2.5.1"><a href="#section-6.2.5" class="xref">6.2.5</a>.  <a href="#name-backward-compatibility" class="xref">Backward Compatibility</a></p>
---
>                     <p id="section-toc.1-1.6.2.2.2.5.1"><a href="#section-6.2.5" class="auto internal xref">6.2.5</a>.  <a href="#name-backward-compatibility" class="internal xref">Backward Compatibility</a></p>
1346c1367
<                 <p id="section-toc.1-1.6.2.3.1"><a href="#section-6.3" class="xref">6.3</a>.  <a href="#name-in-network-caching" class="xref">In-Network Caching</a></p>
---
>                 <p id="section-toc.1-1.6.2.3.1"><a href="#section-6.3" class="auto internal xref">6.3</a>.  <a href="#name-in-network-caching" class="internal xref">In-Network Caching</a></p>
1349c1370
<                 <p id="section-toc.1-1.6.2.4.1"><a href="#section-6.4" class="xref">6.4</a>.  <a href="#name-seamless-consumer-mobility" class="xref">Seamless Consumer Mobility</a></p>
---
>                 <p id="section-toc.1-1.6.2.4.1"><a href="#section-6.4" class="auto internal xref">6.4</a>.  <a href="#name-seamless-consumer-mobility" class="internal xref">Seamless Consumer Mobility</a></p>
1354c1375
<             <p id="section-toc.1-1.7.1"><a href="#section-7" class="xref">7</a>.  <a href="#name-challenges" class="xref">Challenges</a></p>
---
>             <p id="section-toc.1-1.7.1"><a href="#section-7" class="auto internal xref">7</a>.  <a href="#name-challenges" class="internal xref">Challenges</a></p>
1357c1378
<                 <p id="section-toc.1-1.7.2.1.1"><a href="#section-7.1" class="xref">7.1</a>.  <a href="#name-adoption-of-convolutional-c" class="xref">Adoption of Convolutional Coding</a></p>
---
>                 <p id="section-toc.1-1.7.2.1.1"><a href="#section-7.1" class="auto internal xref">7.1</a>.  <a href="#name-adoption-of-convolutional-c" class="internal xref">Adoption of Convolutional Coding</a></p>
1360c1381
<                 <p id="section-toc.1-1.7.2.2.1"><a href="#section-7.2" class="xref">7.2</a>.  <a href="#name-rate-and-congestion-control" class="xref">Rate and Congestion Control</a></p>
---
>                 <p id="section-toc.1-1.7.2.2.1"><a href="#section-7.2" class="auto internal xref">7.2</a>.  <a href="#name-rate-and-congestion-control" class="internal xref">Rate and Congestion Control</a></p>
1363c1384
<                 <p id="section-toc.1-1.7.2.3.1"><a href="#section-7.3" class="xref">7.3</a>.  <a href="#name-security" class="xref">Security</a></p>
---
>                 <p id="section-toc.1-1.7.2.3.1"><a href="#section-7.3" class="auto internal xref">7.3</a>.  <a href="#name-security" class="internal xref">Security</a></p>
1366c1387
<                 <p id="section-toc.1-1.7.2.4.1"><a href="#section-7.4" class="xref">7.4</a>.  <a href="#name-routing-scalability" class="xref">Routing Scalability</a></p>
---
>                 <p id="section-toc.1-1.7.2.4.1"><a href="#section-7.4" class="auto internal xref">7.4</a>.  <a href="#name-routing-scalability" class="internal xref">Routing Scalability</a></p>
1371c1392
<             <p id="section-toc.1-1.8.1"><a href="#section-8" class="xref">8</a>.  <a href="#name-iana-considerations" class="xref">IANA Considerations</a></p>
---
>             <p id="section-toc.1-1.8.1"><a href="#section-8" class="auto internal xref">8</a>.  <a href="#name-iana-considerations" class="internal xref">IANA Considerations</a></p>
1374c1395
<             <p id="section-toc.1-1.9.1"><a href="#section-9" class="xref">9</a>.  <a href="#name-security-considerations" class="xref">Security Considerations</a></p>
---
>             <p id="section-toc.1-1.9.1"><a href="#section-9" class="auto internal xref">9</a>.  <a href="#name-security-considerations" class="internal xref">Security Considerations</a></p>
1377c1398
<             <p id="section-toc.1-1.10.1"><a href="#section-10" class="xref">10</a>. <a href="#name-informative-references" class="xref">Informative References</a></p>
---
>             <p id="section-toc.1-1.10.1"><a href="#section-10" class="auto internal xref">10</a>. <a href="#name-informative-references" class="internal xref">Informative References</a></p>
1380c1401
<             <p id="section-toc.1-1.11.1"><a href="#appendix-A" class="xref"></a><a href="#name-acknowledgments" class="xref">Acknowledgments</a></p>
---
>             <p id="section-toc.1-1.11.1"><a href="#appendix-A" class="auto internal xref"></a><a href="#name-acknowledgments" class="internal xref">Acknowledgments</a></p>
1383c1404
<             <p id="section-toc.1-1.12.1"><a href="#appendix-B" class="xref"></a><a href="#name-authors-addresses" class="xref">Authors' Addresses</a></p>
---
>             <p id="section-toc.1-1.12.1"><a href="#appendix-B" class="auto internal xref"></a><a href="#name-authors-addresses" class="internal xref">Authors' Addresses</a></p>
1393,1396c1414,1417
< <p id="section-1-1">Information-Centric Networking (ICN), in general, and Content-Centric Networking (CCNx) <span>[<a href="#Jacobson09" class="xref">1</a>]</span> or Named Data Networking (NDN) <span>[<a href="#Zhang14" class="xref">2</a>]</span>, in particular, have emerged as a novel communication paradigm that advocates for the retrieval of data based on their names. This paradigm pushes content awareness into the network layer. It is expected to enable consumers to obtain the content they desire in a straightforward and efficient manner from the heterogenous networks they may be connected to. The CCNx/NDN architecture has introduced innovative ideas and has stimulated research in a variety of areas, such as in-network caching, name-based routing, multipath transport, and content security. One key benefit of requesting content by name is that it eliminates the requirement to establish a session between the client and a specific server, and the content can thereby be retrieved from multiple sources.<a href="#section-1-1" class="pilcrow">¶</a></p>
< <p id="section-1-2">In parallel, there has been a growing interest in both academia and industry for better understanding the fundamental aspects of Network Coding (NC) toward enhancing key system performance metrics, such as data throughput, robustness and reduction in the required number of transmissions through connected networks, and redundant transmission on broadcast or point-to-multipoint connections. NC is a technique that is typically used for encoding packets to recover from lost source packets at the receiver and for effectively obtaining the desired information in a fully distributed manner. In addition, in terms of security aspects, NC can be managed using a practical security scheme that deals with pollution attacks <span>[<a href="#Gkantsidis06" class="xref">3</a>]</span> and can be utilized for preventing eavesdroppers from obtaining meaningful information <span>[<a href="#Cai02" class="xref">4</a>]</span> or protecting a wireless video stream while retaining the NC benefits <span>[<a href="#Lima10" class="xref">5</a>]</span> <span>[<a href="#Vilela08" class="xref">6</a>]</span>.<a href="#section-1-2" class="pilcrow">¶</a></p>
< <p id="section-1-3">From the perspective of the NC transport mechanism, NC can be divided into two major categories: coherent NC and noncoherent NC <span>[<a href="#Koetter03" class="xref">7</a>]</span>  <span>[<a href="#Vyetrenko09" class="xref">8</a>]</span>. In coherent NC, the source and destination nodes know the exact network topology and the coding operations available at intermediate nodes. When multiple consumers are attempting to receive the same content, such as live video streaming, coherent NC could enable optimal throughput by sending the content flow over the constructed optimal multicast trees <span>[<a href="#Wu04" class="xref">9</a>]</span>. However, it requires a fully adjustable and specific routing mechanism and a large computational capacity for central coordination. In the case of noncoherent NC, which often uses Random Linear Coding (RLC), it is not necessary to know the network topology nor the intermediate coding operations <span>[<a href="#Ho06" class="xref">10</a>]</span>. As noncoherent NC works in a completely independent and decentralized manner, this approach is more feasible in terms of eliminating such a central coordination.<a href="#section-1-3" class="pilcrow">¶</a></p>
< <p id="section-1-4">NC combines multiple packets together with parts of the same content and may do this at the source and/or at other nodes in the network. Network coded packets are not associated with a specific server, as they may have been combined within the network. As NC is focused on what information should be encoded in a network packet instead of the specific host at which it has been generated, it is in line with the architecture of the CCNx/NDN core networking layer. NC allows for recovery of missing packets by encoding the information across several packets. ICN is synergistic with NC, as it allows for caching of data packets throughout the network. In a typical network that uses NC, the sender must transmit enough packets to retrieve the original data. ICN offers an opportunity to retrieve network-coded packets directly from caches in the network, making the combination of ICN and NC particularly effective. In fact, NC has already been implemented for information/content dissemination <span>[<a href="#Dimarkis10" class="xref">11</a>]</span> <span>[<a href="#Gkantsidis05" class="xref">12</a>]</span> <span>[<a href="#Seferoglu07" class="xref">13</a>]</span>.  Montpetit et al. first suggested that NC techniques be exploited to enhance key aspects of system performance in ICN <span>[<a href="#Montpetit12" class="xref">14</a>]</span>. Although CCNx/NDN excels to exploit the benefits of NC (as described in <a href="#Advantages" class="xref">Section 5</a>), some technical considerations are needed to combine NC and CCNx/NDN owing to the unique features of CCNx/NDN (as described in <a href="#TecCons" class="xref">Section 6</a>).<a href="#section-1-4" class="pilcrow">¶</a></p>
---
> <p id="section-1-1">Information-Centric Networking (ICN), in general, and Content-Centric Networking (CCNx) <span>[<a href="#Jacobson09" class="cite xref">1</a>]</span> or Named Data Networking (NDN) <span>[<a href="#Zhang14" class="cite xref">2</a>]</span>, in particular, have emerged as a novel communication paradigm that advocates for the retrieval of data based on their names. This paradigm pushes content awareness into the network layer. It is expected to enable consumers to obtain the content they desire in a straightforward and efficient manner from the heterogenous networks they may be connected to. The CCNx/NDN architecture has introduced innovative ideas and has stimulated research in a variety of areas, such as in-network caching, name-based routing, multipath transport, and content security. One key benefit of requesting content by name is that it eliminates the requirement to establish a session between the client and a specific server, and the content can thereby be retrieved from multiple sources.<a href="#section-1-1" class="pilcrow">¶</a></p>
> <p id="section-1-2">In parallel, there has been a growing interest in both academia and industry for better understanding the fundamental aspects of Network Coding (NC) toward enhancing key system performance metrics, such as data throughput, robustness and reduction in the required number of transmissions through connected networks, and redundant transmission on broadcast or point-to-multipoint connections. NC is a technique that is typically used for encoding packets to recover from lost source packets at the receiver and for effectively obtaining the desired information in a fully distributed manner. In addition, in terms of security aspects, NC can be managed using a practical security scheme that deals with pollution attacks <span>[<a href="#Gkantsidis06" class="cite xref">3</a>]</span> and can be utilized for preventing eavesdroppers from obtaining meaningful information <span>[<a href="#Cai02" class="cite xref">4</a>]</span> or protecting a wireless video stream while retaining the NC benefits <span>[<a href="#Lima10" class="cite xref">5</a>]</span> <span>[<a href="#Vilela08" class="cite xref">6</a>]</span>.<a href="#section-1-2" class="pilcrow">¶</a></p>
> <p id="section-1-3">From the perspective of the NC transport mechanism, NC can be divided into two major categories: coherent NC and noncoherent NC <span>[<a href="#Koetter03" class="cite xref">7</a>]</span>  <span>[<a href="#Vyetrenko09" class="cite xref">8</a>]</span>. In coherent NC, the source and destination nodes know the exact network topology and the coding operations available at intermediate nodes. When multiple consumers are attempting to receive the same content, such as live video streaming, coherent NC could enable optimal throughput by sending the content flow over the constructed optimal multicast trees <span>[<a href="#Wu04" class="cite xref">9</a>]</span>. However, it requires a fully adjustable and specific routing mechanism and a large computational capacity for central coordination. In the case of noncoherent NC, which often uses Random Linear Coding (RLC), it is not necessary to know the network topology nor the intermediate coding operations <span>[<a href="#Ho06" class="cite xref">10</a>]</span>. As noncoherent NC works in a completely independent and decentralized manner, this approach is more feasible in terms of eliminating such a central coordination.<a href="#section-1-3" class="pilcrow">¶</a></p>
> <p id="section-1-4">NC combines multiple packets together with parts of the same content and may do this at the source and/or at other nodes in the network. Network coded packets are not associated with a specific server, as they may have been combined within the network. As NC is focused on what information should be encoded in a network packet instead of the specific host at which it has been generated, it is in line with the architecture of the CCNx/NDN core networking layer. NC allows for recovery of missing packets by encoding the information across several packets. ICN is synergistic with NC, as it allows for caching of data packets throughout the network. In a typical network that uses NC, the sender must transmit enough packets to retrieve the original data. ICN offers an opportunity to retrieve network-coded packets directly from caches in the network, making the combination of ICN and NC particularly effective. In fact, NC has already been implemented for information/content dissemination <span>[<a href="#Dimarkis10" class="cite xref">11</a>]</span> <span>[<a href="#Gkantsidis05" class="cite xref">12</a>]</span> <span>[<a href="#Seferoglu07" class="cite xref">13</a>]</span>.  Montpetit et al. first suggested that NC techniques be exploited to enhance key aspects of system performance in ICN <span>[<a href="#Montpetit12" class="cite xref">14</a>]</span>. Although CCNx/NDN excels to exploit the benefits of NC (as described in <a href="#Advantages" class="auto internal xref">Section 5</a>), some technical considerations are needed to combine NC and CCNx/NDN owing to the unique features of CCNx/NDN (as described in <a href="#TecCons" class="auto internal xref">Section 6</a>).<a href="#section-1-4" class="pilcrow">¶</a></p>
1408c1429
< <p id="section-2.1-1">This section provides the terms related to NC used in this document, which are defined in RFC 8406 <span>[<a href="#RFC8406" class="xref">15</a>]</span> and produced by the NWCRG.<a href="#section-2.1-1" class="pilcrow">¶</a></p>
---
> <p id="section-2.1-1">This section provides the terms related to NC used in this document, which are defined in RFC 8406 <span>[<a href="#RFC8406" class="cite xref">15</a>]</span> and produced by the NWCRG.<a href="#section-2.1-1" class="pilcrow">¶</a></p>
1474c1495
< <p id="section-2.2-1">The terminology regarding CCNx/NDN used in this document is defined in RFC 8793 <span>[<a href="#RFC8793" class="xref">16</a>]</span>, which was produced by the ICNRG. They are consistent with the relevant documents (<span>[<a href="#RFC8569" class="xref">17</a>]</span> <span>[<a href="#RFC8609" class="xref">18</a>]</span>).<a href="#section-2.2-1" class="pilcrow">¶</a></p>
---
> <p id="section-2.2-1">The terminology regarding CCNx/NDN used in this document is defined in RFC 8793 <span>[<a href="#RFC8793" class="cite xref">16</a>]</span>, which was produced by the ICNRG. They are consistent with the relevant documents (<span>[<a href="#RFC8569" class="cite xref">17</a>]</span> <span>[<a href="#RFC8609" class="cite xref">18</a>]</span>).<a href="#section-2.2-1" class="pilcrow">¶</a></p>
1481,1484c1502,1505
< <p id="section-3-1">We briefly explain the key concepts of CCNx/NDN. In a CCNx/NDN network, there are two types of packets at the network level: interest and data packet (defined in <span><a href="https://www.rfc-editor.org/rfc/rfc8793#section-3.4" class="relref">Section 3.4</a> of [<a href="#RFC8793" class="xref">16</a>]</span>). The term "content object", which means a unit of content data, is an alias to data packet <span>[<a href="#RFC8793" class="xref">16</a>]</span>. The ICN consumer (defined in <span><a href="https://www.rfc-editor.org/rfc/rfc8793#section-3.2" class="relref">Section 3.2</a> of [<a href="#RFC8793" class="xref">16</a>]</span>)  requests a content object by sending an interest that carries the name of the data.<a href="#section-3-1" class="pilcrow">¶</a></p>
< <p id="section-3-2">Once an ICN forwarder (defined in <span><a href="https://www.rfc-editor.org/rfc/rfc8793#section-3.2" class="relref">Section 3.2</a> of [<a href="#RFC8793" class="xref">16</a>]</span>) receives an interest, it performs a series of lookups. First, it checks if it has a copy of the requested content object available in the cache storage, called Content Store (CS) (defined in <span><a href="https://www.rfc-editor.org/rfc/rfc8793#section-3.3" class="relref">Section 3.3</a> of [<a href="#RFC8793" class="xref">16</a>]</span>). If it does, it returns the data, and the transaction is considered to have been successfully completed.<a href="#section-3-2" class="pilcrow">¶</a></p>
< <p id="section-3-3">If it does not have a copy of the requested content object in the CS, it performs a lookup of the Pending Interest Table (PIT) (defined in <span><a href="https://www.rfc-editor.org/rfc/rfc8793#section-3.3" class="relref">Section 3.3</a> of [<a href="#RFC8793" class="xref">16</a>]</span>) to check if there is already an outgoing interest for the same content object. If there is no such interest, then it creates an entry in the PIT that lists the name included in the interest and the interfaces from which it received the interest. This is later used to send the content object back, as interest packets do not carry a source field that identifies the consumer. If there is already a PIT entry for this name, it is updated with the incoming interface of this new interest, and the interest is discarded.<a href="#section-3-3" class="pilcrow">¶</a></p>
< <p id="section-3-4">After the PIT lookup, the interest undergoes a Forwarding Information Base (FIB) (defined in <span><a href="https://www.rfc-editor.org/rfc/rfc8793#section-3.3" class="relref">Section 3.3</a> of [<a href="#RFC8793" class="xref">16</a>]</span>) lookup for selecting an outgoing interface. The FIB lists name prefixes and their corresponding forwarding interfaces in order to send the interest toward a forwarder that possesses a copy of the requested data.<a href="#section-3-4" class="pilcrow">¶</a></p>
---
> <p id="section-3-1">We briefly explain the key concepts of CCNx/NDN. In a CCNx/NDN network, there are two types of packets at the network level: interest and data packet (defined in <span><a href="https://rfc-editor.org/rfc/rfc8793#section-3.4" class="relref">Section 3.4</a> of [<a href="#RFC8793" class="cite xref">16</a>]</span>). The term "content object", which means a unit of content data, is an alias to data packet <span>[<a href="#RFC8793" class="cite xref">16</a>]</span>. The ICN consumer (defined in <span><a href="https://rfc-editor.org/rfc/rfc8793#section-3.2" class="relref">Section 3.2</a> of [<a href="#RFC8793" class="cite xref">16</a>]</span>)  requests a content object by sending an interest that carries the name of the data.<a href="#section-3-1" class="pilcrow">¶</a></p>
> <p id="section-3-2">Once an ICN forwarder (defined in <span><a href="https://rfc-editor.org/rfc/rfc8793#section-3.2" class="relref">Section 3.2</a> of [<a href="#RFC8793" class="cite xref">16</a>]</span>) receives an interest, it performs a series of lookups. First, it checks if it has a copy of the requested content object available in the cache storage, called Content Store (CS) (defined in <span><a href="https://rfc-editor.org/rfc/rfc8793#section-3.3" class="relref">Section 3.3</a> of [<a href="#RFC8793" class="cite xref">16</a>]</span>). If it does, it returns the data, and the transaction is considered to have been successfully completed.<a href="#section-3-2" class="pilcrow">¶</a></p>
> <p id="section-3-3">If it does not have a copy of the requested content object in the CS, it performs a lookup of the Pending Interest Table (PIT) (defined in <span><a href="https://rfc-editor.org/rfc/rfc8793#section-3.3" class="relref">Section 3.3</a> of [<a href="#RFC8793" class="cite xref">16</a>]</span>) to check if there is already an outgoing interest for the same content object. If there is no such interest, then it creates an entry in the PIT that lists the name included in the interest and the interfaces from which it received the interest. This is later used to send the content object back, as interest packets do not carry a source field that identifies the consumer. If there is already a PIT entry for this name, it is updated with the incoming interface of this new interest, and the interest is discarded.<a href="#section-3-3" class="pilcrow">¶</a></p>
> <p id="section-3-4">After the PIT lookup, the interest undergoes a Forwarding Information Base (FIB) (defined in <span><a href="https://rfc-editor.org/rfc/rfc8793#section-3.3" class="relref">Section 3.3</a> of [<a href="#RFC8793" class="cite xref">16</a>]</span>) lookup for selecting an outgoing interface. The FIB lists name prefixes and their corresponding forwarding interfaces in order to send the interest toward a forwarder that possesses a copy of the requested data.<a href="#section-3-4" class="pilcrow">¶</a></p>
1486,1487c1507,1508
< <p id="section-3-6">Data packets carry some information for verifying data integrity and origin authentication and, in particular, that the data is indeed that which corresponds to the name <span>[<a href="#RFC7927" class="xref">19</a>]</span>. This is necessary because authentication of the object is crucial in CCNx/NDN. However, this step is optional at forwarders in order to speed up the processing.<a href="#section-3-6" class="pilcrow">¶</a></p>
< <p id="section-3-7">The key aspect of CCNx/NDN is that the consumer of the content does not establish a session with a specific server. Indeed, the forwarder or producer (defined in <span><a href="https://www.rfc-editor.org/rfc/rfc8793#section-3.2" class="relref">Section 3.2</a> of [<a href="#RFC8793" class="xref">16</a>]</span>) that returns the content object is not aware of the network location of the consumer, and the consumer is not aware of the network location of the node that provides the content. This, in theory, allows the interests to follow different paths within a network or even to be sent over completely different networks.<a href="#section-3-7" class="pilcrow">¶</a></p>
---
> <p id="section-3-6">Data packets carry some information for verifying data integrity and origin authentication and, in particular, that the data is indeed that which corresponds to the name <span>[<a href="#RFC7927" class="cite xref">19</a>]</span>. This is necessary because authentication of the object is crucial in CCNx/NDN. However, this step is optional at forwarders in order to speed up the processing.<a href="#section-3-6" class="pilcrow">¶</a></p>
> <p id="section-3-7">The key aspect of CCNx/NDN is that the consumer of the content does not establish a session with a specific server. Indeed, the forwarder or producer (defined in <span><a href="https://rfc-editor.org/rfc/rfc8793#section-3.2" class="relref">Section 3.2</a> of [<a href="#RFC8793" class="cite xref">16</a>]</span>) that returns the content object is not aware of the network location of the consumer, and the consumer is not aware of the network location of the node that provides the content. This, in theory, allows the interests to follow different paths within a network or even to be sent over completely different networks.<a href="#section-3-7" class="pilcrow">¶</a></p>
1496c1517
< <p id="section-4-4">At the consumer, decoding is performed by solving a set of linear equations that are represented by the coding vectors of the received source and repair packets (possibly only repair packets) within a certain generation. In order to obtain all the source packets, the consumer requires K linearly independent equations. In other words, the consumer must receive at least K linearly independent data packets (called innovative packets). As receiving a linearly dependent data packet is not useful for decoding, recoding should generate and provide innovative packets. One of the major benefits of RLC is that, even for a small-sized finite field (e.g., q=2<sup>8</sup>), the probability of generating linearly dependent packets is negligible <span>[<a href="#Wu04" class="xref">9</a>]</span>.<a href="#section-4-4" class="pilcrow">¶</a></p>
---
> <p id="section-4-4">At the consumer, decoding is performed by solving a set of linear equations that are represented by the coding vectors of the received source and repair packets (possibly only repair packets) within a certain generation. In order to obtain all the source packets, the consumer requires K linearly independent equations. In other words, the consumer must receive at least K linearly independent data packets (called innovative packets). As receiving a linearly dependent data packet is not useful for decoding, recoding should generate and provide innovative packets. One of the major benefits of RLC is that, even for a small-sized finite field (e.g., q=2<sup>8</sup>), the probability of generating linearly dependent packets is negligible <span>[<a href="#Wu04" class="cite xref">9</a>]</span>.<a href="#section-4-4" class="pilcrow">¶</a></p>
1503,1505c1524,1526
< <p id="section-5-1">Combining NC and CCNx/NDN can contribute to effective large-scale content/information dissemination. They individually provide similar benefits, such as throughput/capacity gain and robustness enhancement. The difference between their approaches is that the former considers content flow as algebraic information that is to be combined <span>[<a href="#Koetter03" class="xref">7</a>]</span>, while the latter focuses on the content/information itself at the networking layer. Because these approaches are complementary and their combination would be advantageous, it is natural to combine them.<a href="#section-5-1" class="pilcrow">¶</a></p>
< <p id="section-5-2">The name-based communication in CCNx/NDN enables consumers to obtain requested content objects without establishing and maintaining end-to-end communication channels between nodes. This feature facilitates the exploitation of the in-network cache and multipath/multisource retrieval and also supports consumer mobility without the need for updating the location information/identifier during handover <span>[<a href="#Jacobson09" class="xref">1</a>]</span>. Furthermore, the name-based communication intrinsically supports multicast communication because identical interests are aggregated at the forwarders.<a href="#section-5-2" class="pilcrow">¶</a></p>
< <p id="section-5-3">NC can enable the CCNx/NDN transport system to effectively distribute and cache the data associated with multipath data retrieval <span>[<a href="#Montpetit12" class="xref">14</a>]</span>. Exploiting multipath data retrieval and in-network caching with NC contributes to not only improving the cache hit rate but also expanding the anonymity set of each consumer (the set of potential routers that can serve a given consumer) <span>[<a href="#Wu16" class="xref">20</a>]</span>. The expansion makes it difficult for adversaries to infer the content consumed by others and thus contributes to improving cache privacy. Others also have introduced some use cases of the application of NC in CCNx/NDN, such as the cases of content dissemination with in-network caching <span>[<a href="#Saltarin16" class="xref">21</a>]</span> <span>[<a href="#Wang14" class="xref">22</a>]</span> <span>[<a href="#Wang16" class="xref">23</a>]</span>, seamless consumer mobility <span>[<a href="#Ramakrishnan12" class="xref">24</a>]</span> <span>[<a href="#Carofiglio16" class="xref">25</a>]</span>, and low-latency low-loss video streaming <span>[<a href="#Matsuzono17" class="xref">26</a>]</span>. In this context, it is well worth considering NC integration in CCNx/NDN.<a href="#section-5-3" class="pilcrow">¶</a></p>
---
> <p id="section-5-1">Combining NC and CCNx/NDN can contribute to effective large-scale content/information dissemination. They individually provide similar benefits, such as throughput/capacity gain and robustness enhancement. The difference between their approaches is that the former considers content flow as algebraic information that is to be combined <span>[<a href="#Koetter03" class="cite xref">7</a>]</span>, while the latter focuses on the content/information itself at the networking layer. Because these approaches are complementary and their combination would be advantageous, it is natural to combine them.<a href="#section-5-1" class="pilcrow">¶</a></p>
> <p id="section-5-2">The name-based communication in CCNx/NDN enables consumers to obtain requested content objects without establishing and maintaining end-to-end communication channels between nodes. This feature facilitates the exploitation of the in-network cache and multipath/multisource retrieval and also supports consumer mobility without the need for updating the location information/identifier during handover <span>[<a href="#Jacobson09" class="cite xref">1</a>]</span>. Furthermore, the name-based communication intrinsically supports multicast communication because identical interests are aggregated at the forwarders.<a href="#section-5-2" class="pilcrow">¶</a></p>
> <p id="section-5-3">NC can enable the CCNx/NDN transport system to effectively distribute and cache the data associated with multipath data retrieval <span>[<a href="#Montpetit12" class="cite xref">14</a>]</span>. Exploiting multipath data retrieval and in-network caching with NC contributes to not only improving the cache hit rate but also expanding the anonymity set of each consumer (the set of potential routers that can serve a given consumer) <span>[<a href="#Wu16" class="cite xref">20</a>]</span>. The expansion makes it difficult for adversaries to infer the content consumed by others and thus contributes to improving cache privacy. Others also have introduced some use cases of the application of NC in CCNx/NDN, such as the cases of content dissemination with in-network caching <span>[<a href="#Saltarin16" class="cite xref">21</a>]</span> <span>[<a href="#Wang14" class="cite xref">22</a>]</span> <span>[<a href="#Wang16" class="cite xref">23</a>]</span>, seamless consumer mobility <span>[<a href="#Ramakrishnan12" class="cite xref">24</a>]</span> <span>[<a href="#Carofiglio16" class="cite xref">25</a>]</span>, and low-latency low-loss video streaming <span>[<a href="#Matsuzono17" class="cite xref">26</a>]</span>. In this context, it is well worth considering NC integration in CCNx/NDN.<a href="#section-5-3" class="pilcrow">¶</a></p>
1519c1540
< <p id="section-6.1-1">Naming content objects is as important for CCNx/NDN as naming hosts is in the current-day Internet <span>[<a href="#RFC7927" class="xref">19</a>]</span>. In this section, two possible naming schemes are presented.<a href="#section-6.1-1" class="pilcrow">¶</a></p>
---
> <p id="section-6.1-1">Naming content objects is as important for CCNx/NDN as naming hosts is in the current-day Internet <span>[<a href="#RFC7927" class="cite xref">19</a>]</span>. In this section, two possible naming schemes are presented.<a href="#section-6.1-1" class="pilcrow">¶</a></p>
1524c1545
< <p id="section-6.1.1-1">Each source and repair packet (hereinafter referred to as NC packet) may have a unique name, as each original content object has in CCNx/NDN and as PIT and CS operations typically require a unique name for identifying the NC packet. As a method of naming an NC packet that takes into account the feature of block coding, the coding vector and the generation ID can be used as a part of the content object name. As in <span>[<a href="#Saltarin16" class="xref">21</a>]</span>, when the generation ID is "g-id", generation size is 4, and coding vector is (1,0,0,0), the name could be /CCNx.com/video-A/g-id/1000. Some other identifiers and/or parameters related to the encoding scheme can also be used as name components. For instance, the encoding ID specifying the coding scheme may be used with "enc‑id", such as /CCNx.com/video-A/enc-id/g-id/1000, as defined in the FEC Framework (FECFRAME) <span>[<a href="#RFC6363" class="xref">27</a>]</span>. This naming scheme is simple and can support the delivery of NC packets with exactly the same operations in the PIT/CS as those for the content objects.<a href="#section-6.1.1-1" class="pilcrow">¶</a></p>
---
> <p id="section-6.1.1-1">Each source and repair packet (hereinafter referred to as NC packet) may have a unique name, as each original content object has in CCNx/NDN and as PIT and CS operations typically require a unique name for identifying the NC packet. As a method of naming an NC packet that takes into account the feature of block coding, the coding vector and the generation ID can be used as a part of the content object name. As in <span>[<a href="#Saltarin16" class="cite xref">21</a>]</span>, when the generation ID is "g-id", generation size is 4, and coding vector is (1,0,0,0), the name could be /CCNx.com/video-A/g-id/1000. Some other identifiers and/or parameters related to the encoding scheme can also be used as name components. For instance, the encoding ID specifying the coding scheme may be used with "enc‑id", such as /CCNx.com/video-A/enc-id/g-id/1000, as defined in the FEC Framework (FECFRAME) <span>[<a href="#RFC6363" class="cite xref">27</a>]</span>. This naming scheme is simple and can support the delivery of NC packets with exactly the same operations in the PIT/CS as those for the content objects.<a href="#section-6.1.1-1" class="pilcrow">¶</a></p>
1526c1547
< <p id="section-6.1.1-3">In the latter case, partial name matching is required at the data forwarders. As the interest with only the prefix name matches any NC packet with the same prefix, the consumer could immediately obtain an NC packet from a nearby CS (in-network cache) without knowing the coding vectors of the cached NC packets in advance. In the case wherein NC packets in transit are modified by in-network recoding performed at forwarders, the consumer could also receive the modified NC packets. However, in contrast to the former case, the consumer may fail to obtain sufficient degrees of freedom (see <a href="#Router" class="xref">Section 6.2.3</a>). To address this issue, a new TLV type in an interest message may be required for specifying further coding information in order to limit the NC packets to be received. For instance, this is enabled by specifying the coding vectors of innovative packets for the consumer (also called decoding matrix) as in <span>[<a href="#Montpetit12" class="xref">14</a>]</span>. This extension may incur an interest packet of significantly increased size, and it may thus be useful to use compression techniques for coding vectors <span>[<a href="#Thomos12" class="xref">28</a>]</span> <span>[<a href="#Lucani14" class="xref">29</a>]</span>. Without such coding information provided by the interest, the forwarder would be required to maintain some records regarding the interest packets that were satisfied previously (see <a href="#Router" class="xref">Section 6.2.3</a>).<a href="#section-6.1.1-3" class="pilcrow">¶</a></p>
---
> <p id="section-6.1.1-3">In the latter case, partial name matching is required at the data forwarders. As the interest with only the prefix name matches any NC packet with the same prefix, the consumer could immediately obtain an NC packet from a nearby CS (in-network cache) without knowing the coding vectors of the cached NC packets in advance. In the case wherein NC packets in transit are modified by in-network recoding performed at forwarders, the consumer could also receive the modified NC packets. However, in contrast to the former case, the consumer may fail to obtain sufficient degrees of freedom (see <a href="#Router" class="auto internal xref">Section 6.2.3</a>). To address this issue, a new TLV type in an interest message may be required for specifying further coding information in order to limit the NC packets to be received. For instance, this is enabled by specifying the coding vectors of innovative packets for the consumer (also called decoding matrix) as in <span>[<a href="#Montpetit12" class="cite xref">14</a>]</span>. This extension may incur an interest packet of significantly increased size, and it may thus be useful to use compression techniques for coding vectors <span>[<a href="#Thomos12" class="cite xref">28</a>]</span> <span>[<a href="#Lucani14" class="cite xref">29</a>]</span>. Without such coding information provided by the interest, the forwarder would be required to maintain some records regarding the interest packets that were satisfied previously (see <a href="#Router" class="auto internal xref">Section 6.2.3</a>).<a href="#section-6.1.1-3" class="pilcrow">¶</a></p>
1532c1553
< <p id="section-6.1.2-1">An NC packet may have a name that indicates that it is an NC packet and move the coding information into a metadata field in the payload (i.e., the name includes the data type, source, or repair packet). This would not be beneficial for applications or services that may not need to understand the packet payload. Owing to the possibility that multiple NC packets may have the same name, some mechanism is required for the consumer to obtain innovative packets. As described in <a href="#Cache" class="xref">Section 6.3</a>, a mechanism for managing the multiple innovative packets in the CS would also be required. In addition, extra computational overhead would be incurred when the payload is being encrypted.<a href="#section-6.1.2-1" class="pilcrow">¶</a></p>
---
> <p id="section-6.1.2-1">An NC packet may have a name that indicates that it is an NC packet and move the coding information into a metadata field in the payload (i.e., the name includes the data type, source, or repair packet). This would not be beneficial for applications or services that may not need to understand the packet payload. Owing to the possibility that multiple NC packets may have the same name, some mechanism is required for the consumer to obtain innovative packets. As described in <a href="#Cache" class="auto internal xref">Section 6.3</a>, a mechanism for managing the multiple innovative packets in the CS would also be required. In addition, extra computational overhead would be incurred when the payload is being encrypted.<a href="#section-6.1.2-1" class="pilcrow">¶</a></p>
1546c1567
< <p id="section-6.2.1-1">An open question is whether a data forwarder can perform in-network recoding with data packets that are being received in transit or if only the data that matches an interest can be subject to NC operations. In the latter case, encoding or recoding is performed to generate the NC packet at any forwarder that is able to respond to the interest. This could occur when each NC packet has a unique name and interest has the full name. On the other hand, if interest has a partial name without any coding vector information or multiple NC packets have the same name, the former case may occur; recoding occurs anywhere in the network where it is possible to modify the received NC packet and forward it. As CCNx/NDN comprises mechanisms for ensuring the integrity of the data during transfer, in-network recoding introduces complexities in the network that needs consideration for the integrity mechanisms to still work. Similarly, in-network caching of NC packets at forwarders may be valuable; however, the forwarders would require some mechanisms to validate the NC packets (see <a href="#Security" class="xref">Section 9</a>).<a href="#section-6.2.1-1" class="pilcrow">¶</a></p>
---
> <p id="section-6.2.1-1">An open question is whether a data forwarder can perform in-network recoding with data packets that are being received in transit or if only the data that matches an interest can be subject to NC operations. In the latter case, encoding or recoding is performed to generate the NC packet at any forwarder that is able to respond to the interest. This could occur when each NC packet has a unique name and interest has the full name. On the other hand, if interest has a partial name without any coding vector information or multiple NC packets have the same name, the former case may occur; recoding occurs anywhere in the network where it is possible to modify the received NC packet and forward it. As CCNx/NDN comprises mechanisms for ensuring the integrity of the data during transfer, in-network recoding introduces complexities in the network that needs consideration for the integrity mechanisms to still work. Similarly, in-network caching of NC packets at forwarders may be valuable; however, the forwarders would require some mechanisms to validate the NC packets (see <a href="#Security" class="auto internal xref">Section 9</a>).<a href="#section-6.2.1-1" class="pilcrow">¶</a></p>
1553,1555c1574,1576
< <p id="section-6.2.2-1">To obtain NC benefits (possibly associated with in-network caching), the consumer is required to issue interests that direct the forwarder (or producer) to respond with innovative packets if available. In the case where each NC packet may have a unique name (as described in <a href="#Naming" class="xref">Section 6.1</a>), by issuing an interest specifying a unique name with g-id and the coding vector for an NC packet, the consumer could appropriately receive an innovative packet if it is available at some forwarders.<a href="#section-6.2.2-1" class="pilcrow">¶</a></p>
< <p id="section-6.2.2-2">In order to specify the exact name of the NC packet to be retrieved, the consumer is required to know the valid naming scheme. From a practical viewpoint, it is desirable for the consumer application to automatically construct the right name components without depending on any application specifications. To this end, the consumer application may retrieve and refer to a manifest <span>[<a href="#RFC8569" class="xref">17</a>]</span> that enumerates the content objects, including NC packets, or may use some coding scheme specifier as a name component to construct the name components of interests to request innovative packets.<a href="#section-6.2.2-2" class="pilcrow">¶</a></p>
< <p id="section-6.2.2-3">Conversely, the consumer without decoding capability (e.g., specific sensor node) may want to receive only the source packets. As described in <a href="#Naming" class="xref">Section 6.1</a>, because the NC packet can have a name that is explicitly different from source packets, issuing interests for retrieving source packets is possible.<a href="#section-6.2.2-3" class="pilcrow">¶</a></p>
---
> <p id="section-6.2.2-1">To obtain NC benefits (possibly associated with in-network caching), the consumer is required to issue interests that direct the forwarder (or producer) to respond with innovative packets if available. In the case where each NC packet may have a unique name (as described in <a href="#Naming" class="auto internal xref">Section 6.1</a>), by issuing an interest specifying a unique name with g-id and the coding vector for an NC packet, the consumer could appropriately receive an innovative packet if it is available at some forwarders.<a href="#section-6.2.2-1" class="pilcrow">¶</a></p>
> <p id="section-6.2.2-2">In order to specify the exact name of the NC packet to be retrieved, the consumer is required to know the valid naming scheme. From a practical viewpoint, it is desirable for the consumer application to automatically construct the right name components without depending on any application specifications. To this end, the consumer application may retrieve and refer to a manifest <span>[<a href="#RFC8569" class="cite xref">17</a>]</span> that enumerates the content objects, including NC packets, or may use some coding scheme specifier as a name component to construct the name components of interests to request innovative packets.<a href="#section-6.2.2-2" class="pilcrow">¶</a></p>
> <p id="section-6.2.2-3">Conversely, the consumer without decoding capability (e.g., specific sensor node) may want to receive only the source packets. As described in <a href="#Naming" class="auto internal xref">Section 6.1</a>, because the NC packet can have a name that is explicitly different from source packets, issuing interests for retrieving source packets is possible.<a href="#section-6.2.2-3" class="pilcrow">¶</a></p>
1563c1584
< <p id="section-6.2.3-1">If the forwarder constantly responds to the incoming interests by returning non-innovative packets, the consumer(s) cannot decode and obtain the source packets. This issue could happen when 1) incoming interests for NC packets do not specify some coding parameters, such as the coding vectors to be used, and 2) the forwarder does not have a sufficient number of linearly independent NC packets (possibly in the CS) to use for recoding. In this case, the forwarder is required to determine whether or not it can generate innovative packets to be forwarded to the interface(s) at which the interests arrived. An approach to deal with this issue is that the forwarder maintains a tally of the interests for a specific name, generation ID, and the incoming interface(s) in order to record how many degrees of freedom have already been provided <span>[<a href="#Saltarin16" class="xref">21</a>]</span>. As such a scheme requires state management (and potentially timers) in forwarders, scalability and practicality must be considered. In addition, some transport mechanism for in-network loss detection and recovery <span>[<a href="#Carofiglio16" class="xref">25</a>]</span><span>[<a href="#Matsuzono17" class="xref">26</a>]</span> at a forwarder, as well as a consumer-driven mechanism, could be indispensable for enabling fast loss recovery and realizing NC gains. If a forwarder cannot either return a matching innovative packet from its local content store, nor produce on the fly a recoded packet that is innovative, it is important that the forwarder not simply return a non-innovative packet but instead do a forwarding lookup in its FIB and forward the interest toward the producer or upstream forwarder that can provide an innovative packet. In this context, to retrieve an innovative packet effectively and quickly, an appropriate setting of the FIB and efficient interest-forwarding strategies should also be considered.<a href="#section-6.2.3-1" class="pilcrow">¶</a></p>
---
> <p id="section-6.2.3-1">If the forwarder constantly responds to the incoming interests by returning non-innovative packets, the consumer(s) cannot decode and obtain the source packets. This issue could happen when 1) incoming interests for NC packets do not specify some coding parameters, such as the coding vectors to be used, and 2) the forwarder does not have a sufficient number of linearly independent NC packets (possibly in the CS) to use for recoding. In this case, the forwarder is required to determine whether or not it can generate innovative packets to be forwarded to the interface(s) at which the interests arrived. An approach to deal with this issue is that the forwarder maintains a tally of the interests for a specific name, generation ID, and the incoming interface(s) in order to record how many degrees of freedom have already been provided <span>[<a href="#Saltarin16" class="cite xref">21</a>]</span>. As such a scheme requires state management (and potentially timers) in forwarders, scalability and practicality must be considered. In addition, some transport mechanism for in-network loss detection and recovery <span>[<a href="#Carofiglio16" class="cite xref">25</a>]</span><span>[<a href="#Matsuzono17" class="cite xref">26</a>]</span> at a forwarder, as well as a consumer-driven mechanism, could be indispensable for enabling fast loss recovery and realizing NC gains. If a forwarder cannot either return a matching innovative packet from its local content store, nor produce on the fly a recoded packet that is innovative, it is important that the forwarder not simply return a non-innovative packet but instead do a forwarding lookup in its FIB and forward the interest toward the producer or upstream forwarder that can provide an innovative packet. In this context, to retrieve an innovative packet effectively and quickly, an appropriate setting of the FIB and efficient interest-forwarding strategies should also be considered.<a href="#section-6.2.3-1" class="pilcrow">¶</a></p>
1578c1599
<             <li id="section-6.2.4-3.3">The naming scheme for specifying the coding vectors and corresponding NC packets is explicitly represented via a "Manifest" (e.g., FLIC <span>[<a href="#I-D.irtf-icnrg-flic" class="xref">30</a>]</span>) that can be obtained by the consumer and used to select among the available coding vectors and their corresponding packets and thereby send the corresponding interests.<a href="#section-6.2.4-3.3" class="pilcrow">¶</a>
---
>             <li id="section-6.2.4-3.3">The naming scheme for specifying the coding vectors and corresponding NC packets is explicitly represented via a "Manifest" (e.g., FLIC <span>[<a href="#I-D.irtf-icnrg-flic" class="cite xref">30</a>]</span>) that can be obtained by the consumer and used to select among the available coding vectors and their corresponding packets and thereby send the corresponding interests.<a href="#section-6.2.4-3.3" class="pilcrow">¶</a>
1598,1600c1619,1621
< <p id="section-6.3-1"> Caching is a useful technique used for improving throughput and latency in various applications. In-network caching in CCNx/NDN essentially provides support at the network level and is highly beneficial, owing to the involved exploitation of NC for enabling effective multicast transmission <span>[<a href="#Ali16" class="xref">31</a>]</span>, multipath data retrieval <span>[<a href="#Saltarin16" class="xref">21</a>]</span> <span>[<a href="#Ramakrishnan12" class="xref">24</a>]</span>, and fast loss recovery <span>[<a href="#Matsuzono17" class="xref">26</a>]</span>. However, there remain several issues to be considered.<a href="#section-6.3-1" class="pilcrow">¶</a></p>
< <p id="section-6.3-2"> There generally exist limitations in the CS capacity, and the caching policy affects the consumer's performance <span>[<a href="#Perino11" class="xref">32</a>]</span> <span>[<a href="#Podlipnig03" class="xref">33</a>]</span> <span>[<a href="#Rossini13" class="xref">34</a>]</span>. It is thus crucial for forwarders to determine which content objects should be cached and which discarded. As delay-sensitive applications often do not require an in-network cache for a long period, owing to their real-time constraints, forwarders have to know the necessity for caching received content objects to save the caching volume. In CCNx, this could be made possible by setting a Recommended Cache Time (RCT) in the optional header of the data packet at the producer side. The RCT serves as a guideline for the CS cache in determining how long to retain the content object. When the RCT is set as zero, the forwarder recognizes that caching the content object is not useful. Conversely, the forwarder may cache it when the RCT has a greater value. In NDN, the TLV type of FreshnessPeriod could be used.<a href="#section-6.3-2" class="pilcrow">¶</a></p>
< <p id="section-6.3-3">One key aspect of in-network caching is whether or not forwarders can cache NC packets in their CS. They may be caching the NC packets without having the ability to perform a validation of the content objects. Therefore, the caching of the NC packets would require some mechanism to validate the NC packets (see <a href="#Security" class="xref">Section 9</a>). In the case wherein the NC packets have the same name, it would also require some mechanism to identify them.<a href="#section-6.3-3" class="pilcrow">¶</a></p>
---
> <p id="section-6.3-1"> Caching is a useful technique used for improving throughput and latency in various applications. In-network caching in CCNx/NDN essentially provides support at the network level and is highly beneficial, owing to the involved exploitation of NC for enabling effective multicast transmission <span>[<a href="#Ali16" class="cite xref">31</a>]</span>, multipath data retrieval <span>[<a href="#Saltarin16" class="cite xref">21</a>]</span> <span>[<a href="#Ramakrishnan12" class="cite xref">24</a>]</span>, and fast loss recovery <span>[<a href="#Matsuzono17" class="cite xref">26</a>]</span>. However, there remain several issues to be considered.<a href="#section-6.3-1" class="pilcrow">¶</a></p>
> <p id="section-6.3-2"> There generally exist limitations in the CS capacity, and the caching policy affects the consumer's performance <span>[<a href="#Perino11" class="cite xref">32</a>]</span> <span>[<a href="#Podlipnig03" class="cite xref">33</a>]</span> <span>[<a href="#Rossini13" class="cite xref">34</a>]</span>. It is thus crucial for forwarders to determine which content objects should be cached and which discarded. As delay-sensitive applications often do not require an in-network cache for a long period, owing to their real-time constraints, forwarders have to know the necessity for caching received content objects to save the caching volume. In CCNx, this could be made possible by setting a Recommended Cache Time (RCT) in the optional header of the data packet at the producer side. The RCT serves as a guideline for the CS cache in determining how long to retain the content object. When the RCT is set as zero, the forwarder recognizes that caching the content object is not useful. Conversely, the forwarder may cache it when the RCT has a greater value. In NDN, the TLV type of FreshnessPeriod could be used.<a href="#section-6.3-2" class="pilcrow">¶</a></p>
> <p id="section-6.3-3">One key aspect of in-network caching is whether or not forwarders can cache NC packets in their CS. They may be caching the NC packets without having the ability to perform a validation of the content objects. Therefore, the caching of the NC packets would require some mechanism to validate the NC packets (see <a href="#Security" class="auto internal xref">Section 9</a>). In the case wherein the NC packets have the same name, it would also require some mechanism to identify them.<a href="#section-6.3-3" class="pilcrow">¶</a></p>
1608,1609c1629,1630
< <p id="section-6.4-1">A key feature of CCNx/NDN is that it is sessionless, which enables the consumer and forwarder to send multiple interests toward different copies of the content in parallel, by using multiple interfaces at the same time in an asynchronous manner. Through the multipath data retrieval, the consumer could obtain the content from multiple copies that are distributed while using the aggregate capacity of multiple interfaces. For the link between the consumer and the multiple copies, the consumer can perform a certain rate adaptation mechanism for video streaming <span>[<a href="#Ramakrishnan12" class="xref">24</a>]</span> or congestion control for content acquisition <span>[<a href="#acm-mpath-cc" class="xref">35</a>]</span>.<a href="#section-6.4-1" class="pilcrow">¶</a></p>
< <p id="section-6.4-2"> NC adds a reliability layer to CCNx in a distributed and asynchronous manner, because NC provides a mechanism for ensuring that the interests sent to multiple copies of the content in parallel retrieve innovative packets, even in the case of packet losses on some of the paths/networks to these copies. This applies to consumer mobility events <span>[<a href="#Ramakrishnan12" class="xref">24</a>]</span>, wherein the consumer could receive additional degrees of freedom with any innovative packet if at least one available interface exists during the mobility event. An interest-forwarding strategy at the consumer (and possibly forwarder) for efficiently obtaining innovative packets would be required for the consumer to achieve seamless consumer mobility.<a href="#section-6.4-2" class="pilcrow">¶</a></p>
---
> <p id="section-6.4-1">A key feature of CCNx/NDN is that it is sessionless, which enables the consumer and forwarder to send multiple interests toward different copies of the content in parallel, by using multiple interfaces at the same time in an asynchronous manner. Through the multipath data retrieval, the consumer could obtain the content from multiple copies that are distributed while using the aggregate capacity of multiple interfaces. For the link between the consumer and the multiple copies, the consumer can perform a certain rate adaptation mechanism for video streaming <span>[<a href="#Ramakrishnan12" class="cite xref">24</a>]</span> or congestion control for content acquisition <span>[<a href="#acm-mpath-cc" class="cite xref">35</a>]</span>.<a href="#section-6.4-1" class="pilcrow">¶</a></p>
> <p id="section-6.4-2"> NC adds a reliability layer to CCNx in a distributed and asynchronous manner, because NC provides a mechanism for ensuring that the interests sent to multiple copies of the content in parallel retrieve innovative packets, even in the case of packet losses on some of the paths/networks to these copies. This applies to consumer mobility events <span>[<a href="#Ramakrishnan12" class="cite xref">24</a>]</span>, wherein the consumer could receive additional degrees of freedom with any innovative packet if at least one available interface exists during the mobility event. An interest-forwarding strategy at the consumer (and possibly forwarder) for efficiently obtaining innovative packets would be required for the consumer to achieve seamless consumer mobility.<a href="#section-6.4-2" class="pilcrow">¶</a></p>
1623c1644
< <p id="section-7.1-1">Several block coding approaches have been proposed thus far; however, there is still not sufficient discussion and application of the convolutional coding approach (e.g., sliding or elastic window coding) in CCNx/NDN. Convolutional coding is often appropriate for situations wherein a fully or partially reliable delivery of continuous data flows is required and especially when these data flows feature real-time constraints. As in <span>[<a href="#Pierre11" class="xref">36</a>]</span>, on an end-to-end coding basis, it would be advantageous for continuous content flow to adopt sliding window coding in CCNx/NDN. In this case, the producer is required to appropriately set coding parameters and let the consumer know the information, and the consumer is required to send interests augmented with feedback information regarding the data reception and/or decoding status. As CCNx/NDN utilizes the hop-by-hop forwarding state, it would be worth discussing and investigating how convolutional coding can be applied in a hop-by-hop manner and what benefits might accrue. In particular, in the case wherein in-network recoding could occur at forwarders, both the encoding window and CS management would be required, and the corresponding feasibility and practicality should be considered.<a href="#section-7.1-1" class="pilcrow">¶</a></p>
---
> <p id="section-7.1-1">Several block coding approaches have been proposed thus far; however, there is still not sufficient discussion and application of the convolutional coding approach (e.g., sliding or elastic window coding) in CCNx/NDN. Convolutional coding is often appropriate for situations wherein a fully or partially reliable delivery of continuous data flows is required and especially when these data flows feature real-time constraints. As in <span>[<a href="#Pierre11" class="cite xref">36</a>]</span>, on an end-to-end coding basis, it would be advantageous for continuous content flow to adopt sliding window coding in CCNx/NDN. In this case, the producer is required to appropriately set coding parameters and let the consumer know the information, and the consumer is required to send interests augmented with feedback information regarding the data reception and/or decoding status. As CCNx/NDN utilizes the hop-by-hop forwarding state, it would be worth discussing and investigating how convolutional coding can be applied in a hop-by-hop manner and what benefits might accrue. In particular, in the case wherein in-network recoding could occur at forwarders, both the encoding window and CS management would be required, and the corresponding feasibility and practicality should be considered.<a href="#section-7.1-1" class="pilcrow">¶</a></p>
1629,1630c1650,1651
< <p id="section-7.2-1">The addition of redundancy using repair packets may result in further network congestion and could adversely affect the overall throughput. In particular, in a situation wherein fair bandwidth sharing is more desirable, each streaming flow must adapt to the network conditions to fairly consume the available link bandwidth. It is thus necessary that each content flow cooperatively implement congestion control to adjust the consumed bandwidth <span>[<a href="#RFC9265" class="xref">37</a>]</span>. From this perspective, an effective deployment approach (e.g., a forwarder-supported approach that can provide benefits under partial deployment) is required.<a href="#section-7.2-1" class="pilcrow">¶</a></p>
< <p id="section-7.2-2">As described in <a href="#Mobility" class="xref">Section 6.4</a>, NC can contribute to seamless consumer mobility by obtaining innovative packets without receiving duplicated packets through multipath data retrieval, and avoiding duplicated packets has congestion control benefits as well. It can be challenging to develop an effective rate and congestion control mechanism in order to achieve seamless consumer mobility while improving the overall throughput or latency by fully exploiting NC operations.<a href="#section-7.2-2" class="pilcrow">¶</a></p>
---
> <p id="section-7.2-1">The addition of redundancy using repair packets may result in further network congestion and could adversely affect the overall throughput. In particular, in a situation wherein fair bandwidth sharing is more desirable, each streaming flow must adapt to the network conditions to fairly consume the available link bandwidth. It is thus necessary that each content flow cooperatively implement congestion control to adjust the consumed bandwidth <span>[<a href="#RFC9265" class="cite xref">37</a>]</span>. From this perspective, an effective deployment approach (e.g., a forwarder-supported approach that can provide benefits under partial deployment) is required.<a href="#section-7.2-1" class="pilcrow">¶</a></p>
> <p id="section-7.2-2">As described in <a href="#Mobility" class="auto internal xref">Section 6.4</a>, NC can contribute to seamless consumer mobility by obtaining innovative packets without receiving duplicated packets through multipath data retrieval, and avoiding duplicated packets has congestion control benefits as well. It can be challenging to develop an effective rate and congestion control mechanism in order to achieve seamless consumer mobility while improving the overall throughput or latency by fully exploiting NC operations.<a href="#section-7.2-2" class="pilcrow">¶</a></p>
1636,1637c1657,1658
< <p id="section-7.3-1">While CCNx/NDN introduces new security issues at the networking layer that are different from the IP network, such as a cache poisoning, pollution attacks, and a DoS attack using interest packets, some security approaches are already provided <span>[<a href="#RFC7927" class="xref">19</a>]</span> <span>[<a href="#RFC7945" class="xref">38</a>]</span>. The application of NC in CCNx/NDN brings two potential security aspects that need to be dealt with.<a href="#section-7.3-1" class="pilcrow">¶</a></p>
< <p id="section-7.3-2">The first is in-network recoding at forwarders. Some mechanism for ensuring the integrity of the NC packets newly produced by in-network recoding is required in order for consumers or other forwarders to receive valid NC packets. To this end, there are some possible approaches described in <a href="#Security" class="xref">Section 9</a>, but there may be a more effective method with lower complexity and computation overhead.<a href="#section-7.3-2" class="pilcrow">¶</a></p>
---
> <p id="section-7.3-1">While CCNx/NDN introduces new security issues at the networking layer that are different from the IP network, such as a cache poisoning, pollution attacks, and a DoS attack using interest packets, some security approaches are already provided <span>[<a href="#RFC7927" class="cite xref">19</a>]</span> <span>[<a href="#RFC7945" class="cite xref">38</a>]</span>. The application of NC in CCNx/NDN brings two potential security aspects that need to be dealt with.<a href="#section-7.3-1" class="pilcrow">¶</a></p>
> <p id="section-7.3-2">The first is in-network recoding at forwarders. Some mechanism for ensuring the integrity of the NC packets newly produced by in-network recoding is required in order for consumers or other forwarders to receive valid NC packets. To this end, there are some possible approaches described in <a href="#Security" class="auto internal xref">Section 9</a>, but there may be a more effective method with lower complexity and computation overhead.<a href="#section-7.3-2" class="pilcrow">¶</a></p>
1661c1682
< <p id="section-9-1">In-network recoding is a distinguishing feature of NC. Only valid NC packets produced by in-network recoding must be requested and utilized (and possibly stored). To this end, there exist some possible approaches. First, as a signature verification approach, the exploitation of multi-signature capability could be applied. This allows not only the original content producer but also some forwarders responsible for in-network recoding to have their own unique signing key. Each forwarder of the group signs a newly generated NC packet in order for other nodes to be able to validate the data with the signature. The CS may verify the signature within the NC packet before storing it to avoid invalid data caching. Second, as a consumer-dependent approach, the consumer puts a restriction on the matching rule using only the name of the requested data. The interest ambiguity can be clarified by specifying both the name and the key identifier (the producer's public key digest) used for matching to the requested data. This KeyId restriction is built in the CCNx design <span>[<a href="#RFC8569" class="xref">17</a>]</span>. Only the requested data packet satisfying the interest with the KeyId restriction would be forwarded and stored in the CS, thus resulting in a reduction in the chances of cache poisoning. Moreover, in the CCNx design, there exists the rule that the CS obeys in order to avoid amplifying invalid data; if an interest has a KeyId restriction, the CS must not reply unless it knows that the signature on the matching content object is correct. If the CS cannot verify the signature, the interest may be treated as a cache miss and forwarded to the upstream forwarder(s). Third, as a certificate chain management approach (possibly without certificate authority), some mechanism, such as <span>[<a href="#RiHopAuth" class="xref">39</a>]</span>, could be used to establish a trustworthy data delivery path. This approach adopts the hop-by-hop authentication mechanism, wherein the forwarding-integrated hop-by-hop certificate collection is performed to provide suspension certificate chains such that the data retrieval is trustworthy.<a href="#section-9-1" class="pilcrow">¶</a></p>
---
> <p id="section-9-1">In-network recoding is a distinguishing feature of NC. Only valid NC packets produced by in-network recoding must be requested and utilized (and possibly stored). To this end, there exist some possible approaches. First, as a signature verification approach, the exploitation of multi-signature capability could be applied. This allows not only the original content producer but also some forwarders responsible for in-network recoding to have their own unique signing key. Each forwarder of the group signs a newly generated NC packet in order for other nodes to be able to validate the data with the signature. The CS may verify the signature within the NC packet before storing it to avoid invalid data caching. Second, as a consumer-dependent approach, the consumer puts a restriction on the matching rule using only the name of the requested data. The interest ambiguity can be clarified by specifying both the name and the key identifier (the producer's public key digest) used for matching to the requested data. This KeyId restriction is built in the CCNx design <span>[<a href="#RFC8569" class="cite xref">17</a>]</span>. Only the requested data packet satisfying the interest with the KeyId restriction would be forwarded and stored in the CS, thus resulting in a reduction in the chances of cache poisoning. Moreover, in the CCNx design, there exists the rule that the CS obeys in order to avoid amplifying invalid data; if an interest has a KeyId restriction, the CS must not reply unless it knows that the signature on the matching content object is correct. If the CS cannot verify the signature, the interest may be treated as a cache miss and forwarded to the upstream forwarder(s). Third, as a certificate chain management approach (possibly without certificate authority), some mechanism, such as <span>[<a href="#RiHopAuth" class="cite xref">39</a>]</span>, could be used to establish a trustworthy data delivery path. This approach adopts the hop-by-hop authentication mechanism, wherein the forwarding-integrated hop-by-hop certificate collection is performed to provide suspension certificate chains such that the data retrieval is trustworthy.<a href="#section-9-1" class="pilcrow">¶</a></p>
