17c17
< <meta content="xml2rfc 3.5.0" name="generator">
---
> <meta content="xml2rfc 3.18.2" name="generator">
23,40c23,36
<   xml2rfc 3.5.0
<     Python 3.6.10
<     appdirs 1.4.4
<     ConfigArgParse 1.2.3
<     google-i18n-address 2.3.5
<     html5lib 1.0.1
<     intervaltree 3.0.2
<     Jinja2 2.11.2
<     kitchen 1.2.6
<     lxml 4.4.2
<     pycairo 1.19.0
<     pycountry 19.8.18
<     pyflakes 2.1.1
<     PyYAML 5.3.1
<     requests 2.22.0
<     setuptools 40.6.2
<     six 1.14.0
<     WeasyPrint 51
---
>   xml2rfc 3.18.2
>     Python 3.11.6
>     ConfigArgParse 1.7
>     google-i18n-address 3.1.0
>     intervaltree 3.1.0
>     Jinja2 3.1.2
>     lxml 4.9.3
>     platformdirs 3.11.0
>     pycountry 22.3.5
>     PyYAML 6.0.1
>     requests 2.31.0
>     setuptools 65.5.0
>     six 1.16.0
>     wcwidth 0.2.8
42c38
< <link href="rfc8985.xml" rel="alternate" type="application/rfc+xml">
---
> <link href="rfc/rfc8985.xml" rel="alternate" type="application/rfc+xml">
52c48
<   commented changes found necssary during the development of the v3
---
>   commented changes found necessary during the development of the v3
61a58,63
> :root {
>   --font-sans: 'Noto Sans', Arial, Helvetica, sans-serif;
>   --font-serif: 'Noto Serif', 'Times', 'Times New Roman', serif;
>   --font-mono: 'Roboto Mono', Courier, 'Courier New', monospace;
> }
> 
64d65
<   width: extend-to-zoom;
79c80
<   font-family: 'Noto Sans', Arial, Helvetica, sans-serif;
---
>   font-family: var(--font-sans);
81a83
>   overflow-wrap: break-word;
167a170,178
> svg[font-family~="serif" i], svg [font-family~="serif" i] {
>   font-family: var(--font-serif);
> }
> svg[font-family~="sans-serif" i], svg [font-family~="sans-serif" i] {
>   font-family: var(--font-sans);
> }
> svg[font-family~="monospace" i], svg [font-family~="monospace" i] {
>   font-family: var(--font-mono);
> }
182,185d192
<   border: none;
<   /* this isn't optimal, but it's an existence proof.  PrinceXML doesn't
<      support flexbox yet.
<   */
186a194
>   border: none;
209a218,220
> ul.ulBare, li.ulBare {
>   margin-left: 0em !important;
> }
251c262,263
< a[href].selfRef {
---
> a[href].selfRef,
> .iref + a[href].internal {
261c273
< tt, code, pre, code {
---
> tt, code, pre {
263c275
<   font-family: 'Roboto Mono', monospace;
---
>   font-family: var(--font-mono);
302a315,317
> blockquote > *:last-child {
>   margin-bottom: 0;
> }
392a408,413
> /* Fix PDF info block run off issue */
> @media print {
>   #identifiers dd {
>     float: none;
>   }
> }
494c515
<   font-family: "Noto Sans",Arial,Helvetica,sans-serif;
---
>   font-family: var(--font-sans);
634d654
< 
656a677,679
>   .breakable pre {
>     break-inside: auto;
>   }
724c747
<   /* The follwing is commented out here, but set appropriately by in code, as
---
>   /* The following is commented out here, but set appropriately by in code, as
824c847
< tt, code, pre, code {
---
> tt, code, pre {
829c852
< pre.sourcecode,
---
> .sourcecode pre,
865c888
< /* Make the alternative author contact informatio look less like just another
---
> /* Make the alternative author contact information look less like just another
1046a1070
>   .artwork > pre,
1061c1085
< and increase the contrast between border and odd row background sligthtly */
---
> and increase the contrast between border and odd row background slightly */
1067a1092,1094
> tr {
>   break-inside: avoid;
> }
1087c1114
<   break-before: avoid-page;
---
>   break-before: auto;
1118c1145
< /* Text in compact lists should not get extra bottim margin space,
---
> /* Text in compact lists should not get extra bottom margin space,
1143c1170
< /* Tweak the comact list text */
---
> /* Tweak the compact list text */
1161c1188
< dd > div:first-child > pre.sourcecode,
---
> dd > div.sourcecode:first-child,
1169a1197,1204
> /* Make paragraph spacing inside <li> smaller than in body text, to fit better within the list */
> li > p {
>   margin-bottom: 0.5em
> }
> /* Don't let p margin spill out from inside list items */
> li > p:last-of-type:only-child {
>   margin-bottom: 0;
> }
1171a1207
> <link href="https://datatracker.ietf.org/doc/draft-ietf-tcpm-rack-15" rel="prev">
1174c1210
<   <link href="https://datatracker.ietf.org/doc/draft-ietf-tcpm-rack-15" rel="prev">
---
>   <script type="application/javascript">async function addMetadata(){try{const e=document.styleSheets[0].cssRules;for(let t=0;t<e.length;t++)if(/#identifiers/.exec(e[t].selectorText)){const a=e[t].cssText.replace("#identifiers","#external-updates");document.styleSheets[0].insertRule(a,document.styleSheets[0].cssRules.length)}}catch(e){console.log(e)}const e=document.getElementById("external-metadata");if(e)try{var t,a="",o=function(e){const t=document.getElementsByTagName("meta");for(let a=0;a<t.length;a++)if(t[a].getAttribute("name")===e)return t[a].getAttribute("content");return""}("rfc.number");if(o){t="https://www.rfc-editor.org/rfc/rfc"+o+".json";try{const e=await fetch(t);a=await e.json()}catch(e){t=document.URL.indexOf("html")>=0?document.URL.replace(/html$/,"json"):document.URL+".json";const o=await fetch(t);a=await o.json()}}if(!a)return;e.style.display="block";const s="",d="https://datatracker.ietf.org/doc",n="https://datatracker.ietf.org/ipr/search",c="https://www.rfc-editor.org/info",l=a.doc_id.toLowerCase(),i=a.doc_id.slice(0,3).toLowerCase(),f=a.doc_id.slice(3).replace(/^0+/,""),u={status:"Status",obsoletes:"Obsoletes",obsoleted_by:"Obsoleted By",updates:"Updates",updated_by:"Updated By",see_also:"See Also",errata_url:"Errata"};let h="<dl style='overflow:hidden' id='external-updates'>";["status","obsoletes","obsoleted_by","updates","updated_by","see_also","errata_url"].forEach(e=>{if("status"==e){a[e]=a[e].toLowerCase();var t=a[e].split(" "),o=t.length,w="",p=1;for(let e=0;e<o;e++)p<o?w=w+r(t[e])+" ":w+=r(t[e]),p++;a[e]=w}else if("obsoletes"==e||"obsoleted_by"==e||"updates"==e||"updated_by"==e){var g,m="",b=1;g=a[e].length;for(let t=0;t<g;t++)a[e][t]&&(a[e][t]=String(a[e][t]).toLowerCase(),m=b<g?m+"<a href='"+s+"/rfc/".concat(a[e][t])+"'>"+a[e][t].slice(3)+"</a>, ":m+"<a href='"+s+"/rfc/".concat(a[e][t])+"'>"+a[e][t].slice(3)+"</a>",b++);a[e]=m}else if("see_also"==e){var y,L="",C=1;y=a[e].length;for(let t=0;t<y;t++)if(a[e][t]){a[e][t]=String(a[e][t]);var _=a[e][t].slice(0,3),v=a[e][t].slice(3).replace(/^0+/,"");L=C<y?"RFC"!=_?L+"<a href='"+s+"/info/"+_.toLowerCase().concat(v.toLowerCase())+"'>"+_+" "+v+"</a>, ":L+"<a href='"+s+"/info/"+_.toLowerCase().concat(v.toLowerCase())+"'>"+v+"</a>, ":"RFC"!=_?L+"<a href='"+s+"/info/"+_.toLowerCase().concat(v.toLowerCase())+"'>"+_+" "+v+"</a>":L+"<a href='"+s+"/info/"+_.toLowerCase().concat(v.toLowerCase())+"'>"+v+"</a>",C++}a[e]=L}else if("errata_url"==e){var R="";R=a[e]?R+"<a href='"+a[e]+"'>Errata exist</a> | <a href='"+d+"/"+l+"'>Datatracker</a>| <a href='"+n+"/?"+i+"="+f+"&submit="+i+"'>IPR</a> | <a href='"+c+"/"+l+"'>Info page</a>":"<a href='"+d+"/"+l+"'>Datatracker</a> | <a href='"+n+"/?"+i+"="+f+"&submit="+i+"'>IPR</a> | <a href='"+c+"/"+l+"'>Info page</a>",a[e]=R}""!=a[e]?"Errata"==u[e]?h+=`<dt>More info:</dt><dd>${a[e]}</dd>`:h+=`<dt>${u[e]}:</dt><dd>${a[e]}</dd>`:"Errata"==u[e]&&(h+=`<dt>More info:</dt><dd>${a[e]}</dd>`)}),h+="</dl>",e.innerHTML=h}catch(e){console.log(e)}else console.log("Could not locate metadata <div> element");function r(e){return e.charAt(0).toUpperCase()+e.slice(1)}}window.removeEventListener("load",addMetadata),window.addEventListener("load",addMetadata);</script>
1176,1177c1212,1213
< <body>
< <script src="https://www.rfc-editor.org/js/metadata.min.js"></script>
---
> <body class="xml2rfc">
> <script src="metadata.min.js"></script>
1278,1283c1314,1319
< <nav class="toc"><ul class="compact toc ulEmpty">
< <li class="compact toc ulEmpty" id="section-toc.1-1.1">
<             <p id="section-toc.1-1.1.1" class="keepWithNext"><a href="#section-1" class="xref">1</a>.  <a href="#name-introduction" class="xref">Introduction</a><a href="#section-toc.1-1.1.1" class="pilcrow">¶</a></p>
< <ul class="compact toc ulEmpty">
< <li class="compact toc ulEmpty" id="section-toc.1-1.1.2.1">
<                 <p id="section-toc.1-1.1.2.1.1" class="keepWithNext"><a href="#section-1.1" class="xref">1.1</a>.  <a href="#name-background" class="xref">Background</a><a href="#section-toc.1-1.1.2.1.1" class="pilcrow">¶</a></p>
---
> <nav class="toc"><ul class="compact toc ulBare ulEmpty">
> <li class="compact toc ulBare ulEmpty" id="section-toc.1-1.1">
>             <p id="section-toc.1-1.1.1" class="keepWithNext"><a href="#section-1" class="auto internal xref">1</a>.  <a href="#name-introduction" class="internal xref">Introduction</a></p>
> <ul class="compact toc ulBare ulEmpty">
> <li class="compact toc ulBare ulEmpty" id="section-toc.1-1.1.2.1">
>                 <p id="section-toc.1-1.1.2.1.1" class="keepWithNext"><a href="#section-1.1" class="auto internal xref">1.1</a>.  <a href="#name-background" class="internal xref">Background</a></p>
1285,1286c1321,1322
<               <li class="compact toc ulEmpty" id="section-toc.1-1.1.2.2">
<                 <p id="section-toc.1-1.1.2.2.1" class="keepWithNext"><a href="#section-1.2" class="xref">1.2</a>.  <a href="#name-motivation" class="xref">Motivation</a><a href="#section-toc.1-1.1.2.2.1" class="pilcrow">¶</a></p>
---
>               <li class="compact toc ulBare ulEmpty" id="section-toc.1-1.1.2.2">
>                 <p id="section-toc.1-1.1.2.2.1" class="keepWithNext"><a href="#section-1.2" class="auto internal xref">1.2</a>.  <a href="#name-motivation" class="internal xref">Motivation</a></p>
1290,1291c1326,1327
<           <li class="compact toc ulEmpty" id="section-toc.1-1.2">
<             <p id="section-toc.1-1.2.1"><a href="#section-2" class="xref">2</a>.  <a href="#name-terminology" class="xref">Terminology</a><a href="#section-toc.1-1.2.1" class="pilcrow">¶</a></p>
---
>           <li class="compact toc ulBare ulEmpty" id="section-toc.1-1.2">
>             <p id="section-toc.1-1.2.1"><a href="#section-2" class="auto internal xref">2</a>.  <a href="#name-terminology" class="internal xref">Terminology</a></p>
1293,1306c1329,1342
<           <li class="compact toc ulEmpty" id="section-toc.1-1.3">
<             <p id="section-toc.1-1.3.1"><a href="#section-3" class="xref">3</a>.  <a href="#name-rack-tlp-high-level-design" class="xref">RACK-TLP High-Level Design</a><a href="#section-toc.1-1.3.1" class="pilcrow">¶</a></p>
< <ul class="compact toc ulEmpty">
< <li class="compact toc ulEmpty" id="section-toc.1-1.3.2.1">
<                 <p id="section-toc.1-1.3.2.1.1"><a href="#section-3.1" class="xref">3.1</a>.  <a href="#name-rack-time-based-loss-infere" class="xref">RACK: Time-Based Loss Inferences from ACKs</a><a href="#section-toc.1-1.3.2.1.1" class="pilcrow">¶</a></p>
< </li>
<               <li class="compact toc ulEmpty" id="section-toc.1-1.3.2.2">
<                 <p id="section-toc.1-1.3.2.2.1"><a href="#section-3.2" class="xref">3.2</a>.  <a href="#name-tlp-sending-one-segment-to-" class="xref">TLP: Sending One Segment to Probe Losses Quickly with RACK</a><a href="#section-toc.1-1.3.2.2.1" class="pilcrow">¶</a></p>
< </li>
<               <li class="compact toc ulEmpty" id="section-toc.1-1.3.2.3">
<                 <p id="section-toc.1-1.3.2.3.1"><a href="#section-3.3" class="xref">3.3</a>.  <a href="#name-rack-tlp-reordering-resilie" class="xref">RACK-TLP: Reordering Resilience with a Time Threshold</a><a href="#section-toc.1-1.3.2.3.1" class="pilcrow">¶</a></p>
< <ul class="compact toc ulEmpty">
< <li class="compact toc ulEmpty" id="section-toc.1-1.3.2.3.2.1">
<                     <p id="section-toc.1-1.3.2.3.2.1.1"><a href="#section-3.3.1" class="xref">3.3.1</a>.  <a href="#name-reordering-design-rationale" class="xref">Reordering Design Rationale</a><a href="#section-toc.1-1.3.2.3.2.1.1" class="pilcrow">¶</a></p>
---
>           <li class="compact toc ulBare ulEmpty" id="section-toc.1-1.3">
>             <p id="section-toc.1-1.3.1"><a href="#section-3" class="auto internal xref">3</a>.  <a href="#name-rack-tlp-high-level-design" class="internal xref">RACK-TLP High-Level Design</a></p>
> <ul class="compact toc ulBare ulEmpty">
> <li class="compact toc ulBare ulEmpty" id="section-toc.1-1.3.2.1">
>                 <p id="section-toc.1-1.3.2.1.1"><a href="#section-3.1" class="auto internal xref">3.1</a>.  <a href="#name-rack-time-based-loss-infere" class="internal xref">RACK: Time-Based Loss Inferences from ACKs</a></p>
> </li>
>               <li class="compact toc ulBare ulEmpty" id="section-toc.1-1.3.2.2">
>                 <p id="section-toc.1-1.3.2.2.1"><a href="#section-3.2" class="auto internal xref">3.2</a>.  <a href="#name-tlp-sending-one-segment-to-" class="internal xref">TLP: Sending One Segment to Probe Losses Quickly with RACK</a></p>
> </li>
>               <li class="compact toc ulBare ulEmpty" id="section-toc.1-1.3.2.3">
>                 <p id="section-toc.1-1.3.2.3.1"><a href="#section-3.3" class="auto internal xref">3.3</a>.  <a href="#name-rack-tlp-reordering-resilie" class="internal xref">RACK-TLP: Reordering Resilience with a Time Threshold</a></p>
> <ul class="compact toc ulBare ulEmpty">
> <li class="compact toc ulBare ulEmpty" id="section-toc.1-1.3.2.3.2.1">
>                     <p id="section-toc.1-1.3.2.3.2.1.1"><a href="#section-3.3.1" class="auto internal xref">3.3.1</a>.  <a href="#name-reordering-design-rationale" class="internal xref">Reordering Design Rationale</a></p>
1308,1309c1344,1345
<                   <li class="compact toc ulEmpty" id="section-toc.1-1.3.2.3.2.2">
<                     <p id="section-toc.1-1.3.2.3.2.2.1"><a href="#section-3.3.2" class="xref">3.3.2</a>.  <a href="#name-reordering-window-adaptatio" class="xref">Reordering Window Adaptation</a><a href="#section-toc.1-1.3.2.3.2.2.1" class="pilcrow">¶</a></p>
---
>                   <li class="compact toc ulBare ulEmpty" id="section-toc.1-1.3.2.3.2.2">
>                     <p id="section-toc.1-1.3.2.3.2.2.1"><a href="#section-3.3.2" class="auto internal xref">3.3.2</a>.  <a href="#name-reordering-window-adaptatio" class="internal xref">Reordering Window Adaptation</a></p>
1313,1314c1349,1350
<               <li class="compact toc ulEmpty" id="section-toc.1-1.3.2.4">
<                 <p id="section-toc.1-1.3.2.4.1"><a href="#section-3.4" class="xref">3.4</a>.  <a href="#name-an-example-of-rack-tlp-in-a" class="xref">An Example of RACK-TLP in Action: Fast Recovery</a><a href="#section-toc.1-1.3.2.4.1" class="pilcrow">¶</a></p>
---
>               <li class="compact toc ulBare ulEmpty" id="section-toc.1-1.3.2.4">
>                 <p id="section-toc.1-1.3.2.4.1"><a href="#section-3.4" class="auto internal xref">3.4</a>.  <a href="#name-an-example-of-rack-tlp-in-a" class="internal xref">An Example of RACK-TLP in Action: Fast Recovery</a></p>
1316,1317c1352,1353
<               <li class="compact toc ulEmpty" id="section-toc.1-1.3.2.5">
<                 <p id="section-toc.1-1.3.2.5.1"><a href="#section-3.5" class="xref">3.5</a>.  <a href="#name-an-example-of-rack-tlp-in-ac" class="xref">An Example of RACK-TLP in Action: RTO</a><a href="#section-toc.1-1.3.2.5.1" class="pilcrow">¶</a></p>
---
>               <li class="compact toc ulBare ulEmpty" id="section-toc.1-1.3.2.5">
>                 <p id="section-toc.1-1.3.2.5.1"><a href="#section-3.5" class="auto internal xref">3.5</a>.  <a href="#name-an-example-of-rack-tlp-in-ac" class="internal xref">An Example of RACK-TLP in Action: RTO</a></p>
1319,1320c1355,1356
<               <li class="compact toc ulEmpty" id="section-toc.1-1.3.2.6">
<                 <p id="section-toc.1-1.3.2.6.1"><a href="#section-3.6" class="xref">3.6</a>.  <a href="#name-design-summary" class="xref">Design Summary</a><a href="#section-toc.1-1.3.2.6.1" class="pilcrow">¶</a></p>
---
>               <li class="compact toc ulBare ulEmpty" id="section-toc.1-1.3.2.6">
>                 <p id="section-toc.1-1.3.2.6.1"><a href="#section-3.6" class="auto internal xref">3.6</a>.  <a href="#name-design-summary" class="internal xref">Design Summary</a></p>
1324,1325c1360,1361
<           <li class="compact toc ulEmpty" id="section-toc.1-1.4">
<             <p id="section-toc.1-1.4.1"><a href="#section-4" class="xref">4</a>.  <a href="#name-requirements" class="xref">Requirements</a><a href="#section-toc.1-1.4.1" class="pilcrow">¶</a></p>
---
>           <li class="compact toc ulBare ulEmpty" id="section-toc.1-1.4">
>             <p id="section-toc.1-1.4.1"><a href="#section-4" class="auto internal xref">4</a>.  <a href="#name-requirements" class="internal xref">Requirements</a></p>
1327,1331c1363,1367
<           <li class="compact toc ulEmpty" id="section-toc.1-1.5">
<             <p id="section-toc.1-1.5.1"><a href="#section-5" class="xref">5</a>.  <a href="#name-definitions" class="xref">Definitions</a><a href="#section-toc.1-1.5.1" class="pilcrow">¶</a></p>
< <ul class="compact toc ulEmpty">
< <li class="compact toc ulEmpty" id="section-toc.1-1.5.2.1">
<                 <p id="section-toc.1-1.5.2.1.1"><a href="#section-5.1" class="xref">5.1</a>.  <a href="#name-terms" class="xref">Terms</a><a href="#section-toc.1-1.5.2.1.1" class="pilcrow">¶</a></p>
---
>           <li class="compact toc ulBare ulEmpty" id="section-toc.1-1.5">
>             <p id="section-toc.1-1.5.1"><a href="#section-5" class="auto internal xref">5</a>.  <a href="#name-definitions" class="internal xref">Definitions</a></p>
> <ul class="compact toc ulBare ulEmpty">
> <li class="compact toc ulBare ulEmpty" id="section-toc.1-1.5.2.1">
>                 <p id="section-toc.1-1.5.2.1.1"><a href="#section-5.1" class="auto internal xref">5.1</a>.  <a href="#name-terms" class="internal xref">Terms</a></p>
1333,1334c1369,1370
<               <li class="compact toc ulEmpty" id="section-toc.1-1.5.2.2">
<                 <p id="section-toc.1-1.5.2.2.1"><a href="#section-5.2" class="xref">5.2</a>.  <a href="#name-per-segment-variables" class="xref">Per-Segment Variables</a><a href="#section-toc.1-1.5.2.2.1" class="pilcrow">¶</a></p>
---
>               <li class="compact toc ulBare ulEmpty" id="section-toc.1-1.5.2.2">
>                 <p id="section-toc.1-1.5.2.2.1"><a href="#section-5.2" class="auto internal xref">5.2</a>.  <a href="#name-per-segment-variables" class="internal xref">Per-Segment Variables</a></p>
1336,1337c1372,1373
<               <li class="compact toc ulEmpty" id="section-toc.1-1.5.2.3">
<                 <p id="section-toc.1-1.5.2.3.1"><a href="#section-5.3" class="xref">5.3</a>.  <a href="#name-per-connection-variables" class="xref">Per-Connection Variables</a><a href="#section-toc.1-1.5.2.3.1" class="pilcrow">¶</a></p>
---
>               <li class="compact toc ulBare ulEmpty" id="section-toc.1-1.5.2.3">
>                 <p id="section-toc.1-1.5.2.3.1"><a href="#section-5.3" class="auto internal xref">5.3</a>.  <a href="#name-per-connection-variables" class="internal xref">Per-Connection Variables</a></p>
1339,1340c1375,1376
<               <li class="compact toc ulEmpty" id="section-toc.1-1.5.2.4">
<                 <p id="section-toc.1-1.5.2.4.1"><a href="#section-5.4" class="xref">5.4</a>.  <a href="#name-per-connection-timers" class="xref">Per-Connection Timers</a><a href="#section-toc.1-1.5.2.4.1" class="pilcrow">¶</a></p>
---
>               <li class="compact toc ulBare ulEmpty" id="section-toc.1-1.5.2.4">
>                 <p id="section-toc.1-1.5.2.4.1"><a href="#section-5.4" class="auto internal xref">5.4</a>.  <a href="#name-per-connection-timers" class="internal xref">Per-Connection Timers</a></p>
1344,1348c1380,1384
<           <li class="compact toc ulEmpty" id="section-toc.1-1.6">
<             <p id="section-toc.1-1.6.1"><a href="#section-6" class="xref">6</a>.  <a href="#name-rack-algorithm-details" class="xref">RACK Algorithm Details</a><a href="#section-toc.1-1.6.1" class="pilcrow">¶</a></p>
< <ul class="compact toc ulEmpty">
< <li class="compact toc ulEmpty" id="section-toc.1-1.6.2.1">
<                 <p id="section-toc.1-1.6.2.1.1"><a href="#section-6.1" class="xref">6.1</a>.  <a href="#name-upon-transmitting-a-data-se" class="xref">Upon Transmitting a Data Segment</a><a href="#section-toc.1-1.6.2.1.1" class="pilcrow">¶</a></p>
---
>           <li class="compact toc ulBare ulEmpty" id="section-toc.1-1.6">
>             <p id="section-toc.1-1.6.1"><a href="#section-6" class="auto internal xref">6</a>.  <a href="#name-rack-algorithm-details" class="internal xref">RACK Algorithm Details</a></p>
> <ul class="compact toc ulBare ulEmpty">
> <li class="compact toc ulBare ulEmpty" id="section-toc.1-1.6.2.1">
>                 <p id="section-toc.1-1.6.2.1.1"><a href="#section-6.1" class="auto internal xref">6.1</a>.  <a href="#name-upon-transmitting-a-data-se" class="internal xref">Upon Transmitting a Data Segment</a></p>
1350,1351c1386,1387
<               <li class="compact toc ulEmpty" id="section-toc.1-1.6.2.2">
<                 <p id="section-toc.1-1.6.2.2.1"><a href="#section-6.2" class="xref">6.2</a>.  <a href="#name-upon-receiving-an-ack" class="xref">Upon Receiving an ACK</a><a href="#section-toc.1-1.6.2.2.1" class="pilcrow">¶</a></p>
---
>               <li class="compact toc ulBare ulEmpty" id="section-toc.1-1.6.2.2">
>                 <p id="section-toc.1-1.6.2.2.1"><a href="#section-6.2" class="auto internal xref">6.2</a>.  <a href="#name-upon-receiving-an-ack" class="internal xref">Upon Receiving an ACK</a></p>
1353,1354c1389,1390
<               <li class="compact toc ulEmpty" id="section-toc.1-1.6.2.3">
<                 <p id="section-toc.1-1.6.2.3.1"><a href="#section-6.3" class="xref">6.3</a>.  <a href="#name-upon-rto-expiration" class="xref">Upon RTO Expiration</a><a href="#section-toc.1-1.6.2.3.1" class="pilcrow">¶</a></p>
---
>               <li class="compact toc ulBare ulEmpty" id="section-toc.1-1.6.2.3">
>                 <p id="section-toc.1-1.6.2.3.1"><a href="#section-6.3" class="auto internal xref">6.3</a>.  <a href="#name-upon-rto-expiration" class="internal xref">Upon RTO Expiration</a></p>
1358,1374c1394,1410
<           <li class="compact toc ulEmpty" id="section-toc.1-1.7">
<             <p id="section-toc.1-1.7.1"><a href="#section-7" class="xref">7</a>.  <a href="#name-tlp-algorithm-details" class="xref">TLP Algorithm Details</a><a href="#section-toc.1-1.7.1" class="pilcrow">¶</a></p>
< <ul class="compact toc ulEmpty">
< <li class="compact toc ulEmpty" id="section-toc.1-1.7.2.1">
<                 <p id="section-toc.1-1.7.2.1.1"><a href="#section-7.1" class="xref">7.1</a>.  <a href="#name-initializing-state" class="xref">Initializing State</a><a href="#section-toc.1-1.7.2.1.1" class="pilcrow">¶</a></p>
< </li>
<               <li class="compact toc ulEmpty" id="section-toc.1-1.7.2.2">
<                 <p id="section-toc.1-1.7.2.2.1"><a href="#section-7.2" class="xref">7.2</a>.  <a href="#name-scheduling-a-loss-probe" class="xref">Scheduling a Loss Probe</a><a href="#section-toc.1-1.7.2.2.1" class="pilcrow">¶</a></p>
< </li>
<               <li class="compact toc ulEmpty" id="section-toc.1-1.7.2.3">
<                 <p id="section-toc.1-1.7.2.3.1"><a href="#section-7.3" class="xref">7.3</a>.  <a href="#name-sending-a-loss-probe-upon-p" class="xref">Sending a Loss Probe upon PTO Expiration</a><a href="#section-toc.1-1.7.2.3.1" class="pilcrow">¶</a></p>
< </li>
<               <li class="compact toc ulEmpty" id="section-toc.1-1.7.2.4">
<                 <p id="section-toc.1-1.7.2.4.1"><a href="#section-7.4" class="xref">7.4</a>.  <a href="#name-detecting-losses-using-the-" class="xref">Detecting Losses Using the ACK of the Loss Probe</a><a href="#section-toc.1-1.7.2.4.1" class="pilcrow">¶</a></p>
< <ul class="compact toc ulEmpty">
< <li class="compact toc ulEmpty" id="section-toc.1-1.7.2.4.2.1">
<                     <p id="section-toc.1-1.7.2.4.2.1.1"><a href="#section-7.4.1" class="xref">7.4.1</a>.  <a href="#name-general-case-detecting-pack" class="xref">General Case: Detecting Packet Losses Using RACK</a><a href="#section-toc.1-1.7.2.4.2.1.1" class="pilcrow">¶</a></p>
---
>           <li class="compact toc ulBare ulEmpty" id="section-toc.1-1.7">
>             <p id="section-toc.1-1.7.1"><a href="#section-7" class="auto internal xref">7</a>.  <a href="#name-tlp-algorithm-details" class="internal xref">TLP Algorithm Details</a></p>
> <ul class="compact toc ulBare ulEmpty">
> <li class="compact toc ulBare ulEmpty" id="section-toc.1-1.7.2.1">
>                 <p id="section-toc.1-1.7.2.1.1"><a href="#section-7.1" class="auto internal xref">7.1</a>.  <a href="#name-initializing-state" class="internal xref">Initializing State</a></p>
> </li>
>               <li class="compact toc ulBare ulEmpty" id="section-toc.1-1.7.2.2">
>                 <p id="section-toc.1-1.7.2.2.1"><a href="#section-7.2" class="auto internal xref">7.2</a>.  <a href="#name-scheduling-a-loss-probe" class="internal xref">Scheduling a Loss Probe</a></p>
> </li>
>               <li class="compact toc ulBare ulEmpty" id="section-toc.1-1.7.2.3">
>                 <p id="section-toc.1-1.7.2.3.1"><a href="#section-7.3" class="auto internal xref">7.3</a>.  <a href="#name-sending-a-loss-probe-upon-p" class="internal xref">Sending a Loss Probe upon PTO Expiration</a></p>
> </li>
>               <li class="compact toc ulBare ulEmpty" id="section-toc.1-1.7.2.4">
>                 <p id="section-toc.1-1.7.2.4.1"><a href="#section-7.4" class="auto internal xref">7.4</a>.  <a href="#name-detecting-losses-using-the-" class="internal xref">Detecting Losses Using the ACK of the Loss Probe</a></p>
> <ul class="compact toc ulBare ulEmpty">
> <li class="compact toc ulBare ulEmpty" id="section-toc.1-1.7.2.4.2.1">
>                     <p id="section-toc.1-1.7.2.4.2.1.1"><a href="#section-7.4.1" class="auto internal xref">7.4.1</a>.  <a href="#name-general-case-detecting-pack" class="internal xref">General Case: Detecting Packet Losses Using RACK</a></p>
1376,1377c1412,1413
<                   <li class="compact toc ulEmpty" id="section-toc.1-1.7.2.4.2.2">
<                     <p id="section-toc.1-1.7.2.4.2.2.1"><a href="#section-7.4.2" class="xref">7.4.2</a>.  <a href="#name-special-case-detecting-a-si" class="xref">Special Case: Detecting a Single Loss Repaired by the Loss Probe</a><a href="#section-toc.1-1.7.2.4.2.2.1" class="pilcrow">¶</a></p>
---
>                   <li class="compact toc ulBare ulEmpty" id="section-toc.1-1.7.2.4.2.2">
>                     <p id="section-toc.1-1.7.2.4.2.2.1"><a href="#section-7.4.2" class="auto internal xref">7.4.2</a>.  <a href="#name-special-case-detecting-a-si" class="internal xref">Special Case: Detecting a Single Loss Repaired by the Loss Probe</a></p>
1383,1384c1419,1420
<           <li class="compact toc ulEmpty" id="section-toc.1-1.8">
<             <p id="section-toc.1-1.8.1"><a href="#section-8" class="xref">8</a>.  <a href="#name-managing-rack-tlp-timers" class="xref">Managing RACK-TLP Timers</a><a href="#section-toc.1-1.8.1" class="pilcrow">¶</a></p>
---
>           <li class="compact toc ulBare ulEmpty" id="section-toc.1-1.8">
>             <p id="section-toc.1-1.8.1"><a href="#section-8" class="auto internal xref">8</a>.  <a href="#name-managing-rack-tlp-timers" class="internal xref">Managing RACK-TLP Timers</a></p>
1386,1393c1422,1429
<           <li class="compact toc ulEmpty" id="section-toc.1-1.9">
<             <p id="section-toc.1-1.9.1"><a href="#section-9" class="xref">9</a>.  <a href="#name-discussion" class="xref">Discussion</a><a href="#section-toc.1-1.9.1" class="pilcrow">¶</a></p>
< <ul class="compact toc ulEmpty">
< <li class="compact toc ulEmpty" id="section-toc.1-1.9.2.1">
<                 <p id="section-toc.1-1.9.2.1.1"><a href="#section-9.1" class="xref">9.1</a>.  <a href="#name-advantages-and-disadvantage" class="xref">Advantages and Disadvantages</a><a href="#section-toc.1-1.9.2.1.1" class="pilcrow">¶</a></p>
< </li>
<               <li class="compact toc ulEmpty" id="section-toc.1-1.9.2.2">
<                 <p id="section-toc.1-1.9.2.2.1"><a href="#section-9.2" class="xref">9.2</a>.  <a href="#name-relationships-with-other-lo" class="xref">Relationships with Other Loss Recovery Algorithms</a><a href="#section-toc.1-1.9.2.2.1" class="pilcrow">¶</a></p>
---
>           <li class="compact toc ulBare ulEmpty" id="section-toc.1-1.9">
>             <p id="section-toc.1-1.9.1"><a href="#section-9" class="auto internal xref">9</a>.  <a href="#name-discussion" class="internal xref">Discussion</a></p>
> <ul class="compact toc ulBare ulEmpty">
> <li class="compact toc ulBare ulEmpty" id="section-toc.1-1.9.2.1">
>                 <p id="section-toc.1-1.9.2.1.1"><a href="#section-9.1" class="auto internal xref">9.1</a>.  <a href="#name-advantages-and-disadvantage" class="internal xref">Advantages and Disadvantages</a></p>
> </li>
>               <li class="compact toc ulBare ulEmpty" id="section-toc.1-1.9.2.2">
>                 <p id="section-toc.1-1.9.2.2.1"><a href="#section-9.2" class="auto internal xref">9.2</a>.  <a href="#name-relationships-with-other-lo" class="internal xref">Relationships with Other Loss Recovery Algorithms</a></p>
1395,1396c1431,1432
<               <li class="compact toc ulEmpty" id="section-toc.1-1.9.2.3">
<                 <p id="section-toc.1-1.9.2.3.1"><a href="#section-9.3" class="xref">9.3</a>.  <a href="#name-interaction-with-congestion" class="xref">Interaction with Congestion Control</a><a href="#section-toc.1-1.9.2.3.1" class="pilcrow">¶</a></p>
---
>               <li class="compact toc ulBare ulEmpty" id="section-toc.1-1.9.2.3">
>                 <p id="section-toc.1-1.9.2.3.1"><a href="#section-9.3" class="auto internal xref">9.3</a>.  <a href="#name-interaction-with-congestion" class="internal xref">Interaction with Congestion Control</a></p>
1398,1399c1434,1435
<               <li class="compact toc ulEmpty" id="section-toc.1-1.9.2.4">
<                 <p id="section-toc.1-1.9.2.4.1"><a href="#section-9.4" class="xref">9.4</a>.  <a href="#name-tlp-recovery-detection-with" class="xref">TLP Recovery Detection with Delayed ACKs</a><a href="#section-toc.1-1.9.2.4.1" class="pilcrow">¶</a></p>
---
>               <li class="compact toc ulBare ulEmpty" id="section-toc.1-1.9.2.4">
>                 <p id="section-toc.1-1.9.2.4.1"><a href="#section-9.4" class="auto internal xref">9.4</a>.  <a href="#name-tlp-recovery-detection-with" class="internal xref">TLP Recovery Detection with Delayed ACKs</a></p>
1401,1402c1437,1438
<               <li class="compact toc ulEmpty" id="section-toc.1-1.9.2.5">
<                 <p id="section-toc.1-1.9.2.5.1"><a href="#section-9.5" class="xref">9.5</a>.  <a href="#name-rack-tlp-for-other-transpor" class="xref">RACK-TLP for Other Transport Protocols</a><a href="#section-toc.1-1.9.2.5.1" class="pilcrow">¶</a></p>
---
>               <li class="compact toc ulBare ulEmpty" id="section-toc.1-1.9.2.5">
>                 <p id="section-toc.1-1.9.2.5.1"><a href="#section-9.5" class="auto internal xref">9.5</a>.  <a href="#name-rack-tlp-for-other-transpor" class="internal xref">RACK-TLP for Other Transport Protocols</a></p>
1406,1407c1442,1443
<           <li class="compact toc ulEmpty" id="section-toc.1-1.10">
<             <p id="section-toc.1-1.10.1"><a href="#section-10" class="xref">10</a>. <a href="#name-security-considerations" class="xref">Security Considerations</a><a href="#section-toc.1-1.10.1" class="pilcrow">¶</a></p>
---
>           <li class="compact toc ulBare ulEmpty" id="section-toc.1-1.10">
>             <p id="section-toc.1-1.10.1"><a href="#section-10" class="auto internal xref">10</a>. <a href="#name-security-considerations" class="internal xref">Security Considerations</a></p>
1409,1410c1445,1446
<           <li class="compact toc ulEmpty" id="section-toc.1-1.11">
<             <p id="section-toc.1-1.11.1"><a href="#section-11" class="xref">11</a>. <a href="#name-iana-considerations" class="xref">IANA Considerations</a><a href="#section-toc.1-1.11.1" class="pilcrow">¶</a></p>
---
>           <li class="compact toc ulBare ulEmpty" id="section-toc.1-1.11">
>             <p id="section-toc.1-1.11.1"><a href="#section-11" class="auto internal xref">11</a>. <a href="#name-iana-considerations" class="internal xref">IANA Considerations</a></p>
1412,1416c1448,1452
<           <li class="compact toc ulEmpty" id="section-toc.1-1.12">
<             <p id="section-toc.1-1.12.1"><a href="#section-12" class="xref">12</a>. <a href="#name-references" class="xref">References</a><a href="#section-toc.1-1.12.1" class="pilcrow">¶</a></p>
< <ul class="compact toc ulEmpty">
< <li class="compact toc ulEmpty" id="section-toc.1-1.12.2.1">
<                 <p id="section-toc.1-1.12.2.1.1"><a href="#section-12.1" class="xref">12.1</a>.  <a href="#name-normative-references" class="xref">Normative References</a><a href="#section-toc.1-1.12.2.1.1" class="pilcrow">¶</a></p>
---
>           <li class="compact toc ulBare ulEmpty" id="section-toc.1-1.12">
>             <p id="section-toc.1-1.12.1"><a href="#section-12" class="auto internal xref">12</a>. <a href="#name-references" class="internal xref">References</a></p>
> <ul class="compact toc ulBare ulEmpty">
> <li class="compact toc ulBare ulEmpty" id="section-toc.1-1.12.2.1">
>                 <p id="section-toc.1-1.12.2.1.1"><a href="#section-12.1" class="auto internal xref">12.1</a>.  <a href="#name-normative-references" class="internal xref">Normative References</a></p>
1418,1419c1454,1455
<               <li class="compact toc ulEmpty" id="section-toc.1-1.12.2.2">
<                 <p id="section-toc.1-1.12.2.2.1"><a href="#section-12.2" class="xref">12.2</a>.  <a href="#name-informative-references" class="xref">Informative References</a><a href="#section-toc.1-1.12.2.2.1" class="pilcrow">¶</a></p>
---
>               <li class="compact toc ulBare ulEmpty" id="section-toc.1-1.12.2.2">
>                 <p id="section-toc.1-1.12.2.2.1"><a href="#section-12.2" class="auto internal xref">12.2</a>.  <a href="#name-informative-references" class="internal xref">Informative References</a></p>
1423,1424c1459,1460
<           <li class="compact toc ulEmpty" id="section-toc.1-1.13">
<             <p id="section-toc.1-1.13.1"><a href="#section-appendix.a" class="xref"></a><a href="#name-acknowledgments" class="xref">Acknowledgments</a><a href="#section-toc.1-1.13.1" class="pilcrow">¶</a></p>
---
>           <li class="compact toc ulBare ulEmpty" id="section-toc.1-1.13">
>             <p id="section-toc.1-1.13.1"><a href="#appendix-A" class="auto internal xref"></a><a href="#name-acknowledgments" class="internal xref">Acknowledgments</a></p>
1426,1427c1462,1463
<           <li class="compact toc ulEmpty" id="section-toc.1-1.14">
<             <p id="section-toc.1-1.14.1"><a href="#section-appendix.b" class="xref"></a><a href="#name-authors-addresses" class="xref">Authors' Addresses</a><a href="#section-toc.1-1.14.1" class="pilcrow">¶</a></p>
---
>           <li class="compact toc ulBare ulEmpty" id="section-toc.1-1.14">
>             <p id="section-toc.1-1.14.1"><a href="#appendix-B" class="auto internal xref"></a><a href="#name-authors-addresses" class="internal xref">Authors' Addresses</a></p>
1438c1474
< <p id="section-1-1">This document presents RACK-TLP, a TCP loss detection algorithm that improves upon the widely implemented duplicate acknowledgment (DupAck) counting approach described in <span>[<a href="#RFC5681" class="xref">RFC5681</a>]</span> and <span>[<a href="#RFC6675" class="xref">RFC6675</a>]</span>; it is <span class="bcp14">RECOMMENDED</span> as an alternative to that earlier approach. RACK-TLP has two parts. Recent Acknowledgment (RACK) detects losses quickly using time-based inferences derived from ACK feedback. Tail Loss Probe (TLP) triggers ACK feedback by quickly sending a probe segment to avoid retransmission timeout (RTO) events.<a href="#section-1-1" class="pilcrow">¶</a></p>
---
> <p id="section-1-1">This document presents RACK-TLP, a TCP loss detection algorithm that improves upon the widely implemented duplicate acknowledgment (DupAck) counting approach described in <span>[<a href="#RFC5681" class="cite xref">RFC5681</a>]</span> and <span>[<a href="#RFC6675" class="cite xref">RFC6675</a>]</span>; it is <span class="bcp14">RECOMMENDED</span> as an alternative to that earlier approach. RACK-TLP has two parts. Recent Acknowledgment (RACK) detects losses quickly using time-based inferences derived from ACK feedback. Tail Loss Probe (TLP) triggers ACK feedback by quickly sending a probe segment to avoid retransmission timeout (RTO) events.<a href="#section-1-1" class="pilcrow">¶</a></p>
1444,1445c1480,1481
< <p id="section-1.1-1">In traditional TCP loss recovery algorithms <span>[<a href="#RFC5681" class="xref">RFC5681</a>]</span> <span>[<a href="#RFC6675" class="xref">RFC6675</a>]</span>, a sender starts fast recovery when the number of DupAcks received reaches a threshold (DupThresh) that defaults to 3 (this approach is referred to as "DupAck counting" in the rest of the document). The sender also halves the congestion window during the recovery. The rationale behind the partial window reduction is that congestion does not seem severe since ACK clocking is still maintained. The time elapsed in fast recovery can be just one round trip, e.g., if the sender uses SACK-based recovery <span>[<a href="#RFC6675" class="xref">RFC6675</a>]</span> and the number of lost segments is small.<a href="#section-1.1-1" class="pilcrow">¶</a></p>
< <p id="section-1.1-2">If fast recovery is not triggered or is triggered but fails to repair all the losses, then the sender resorts to RTO recovery. The RTO timer interval is conservatively the smoothed RTT (SRTT) plus four times the RTT variation, and is lower bounded to 1 second <span>[<a href="#RFC6298" class="xref">RFC6298</a>]</span>. Upon RTO timer expiration, the sender retransmits the first unacknowledged segment and resets the congestion window to the loss window value (by default, 1 full-sized segment <span>[<a href="#RFC5681" class="xref">RFC5681</a>]</span>). The rationale behind the congestion window reset is that an entire flight of data and the ACK clock were lost, so this deserves a cautious response. The sender then retransmits the rest of the data following the slow start algorithm <span>[<a href="#RFC5681" class="xref">RFC5681</a>]</span>. The time elapsed in RTO recovery is one RTO interval plus the number of round trips needed to repair all the losses.<a href="#section-1.1-2" class="pilcrow">¶</a></p>
---
> <p id="section-1.1-1">In traditional TCP loss recovery algorithms <span>[<a href="#RFC5681" class="cite xref">RFC5681</a>]</span> <span>[<a href="#RFC6675" class="cite xref">RFC6675</a>]</span>, a sender starts fast recovery when the number of DupAcks received reaches a threshold (DupThresh) that defaults to 3 (this approach is referred to as "DupAck counting" in the rest of the document). The sender also halves the congestion window during the recovery. The rationale behind the partial window reduction is that congestion does not seem severe since ACK clocking is still maintained. The time elapsed in fast recovery can be just one round trip, e.g., if the sender uses SACK-based recovery <span>[<a href="#RFC6675" class="cite xref">RFC6675</a>]</span> and the number of lost segments is small.<a href="#section-1.1-1" class="pilcrow">¶</a></p>
> <p id="section-1.1-2">If fast recovery is not triggered or is triggered but fails to repair all the losses, then the sender resorts to RTO recovery. The RTO timer interval is conservatively the smoothed RTT (SRTT) plus four times the RTT variation, and is lower bounded to 1 second <span>[<a href="#RFC6298" class="cite xref">RFC6298</a>]</span>. Upon RTO timer expiration, the sender retransmits the first unacknowledged segment and resets the congestion window to the loss window value (by default, 1 full-sized segment <span>[<a href="#RFC5681" class="cite xref">RFC5681</a>]</span>). The rationale behind the congestion window reset is that an entire flight of data and the ACK clock were lost, so this deserves a cautious response. The sender then retransmits the rest of the data following the slow start algorithm <span>[<a href="#RFC5681" class="cite xref">RFC5681</a>]</span>. The time elapsed in RTO recovery is one RTO interval plus the number of round trips needed to repair all the losses.<a href="#section-1.1-2" class="pilcrow">¶</a></p>
1453c1489
< <p id="section-1.2-1">Fast recovery is the preferred form of loss recovery because it can potentially recover all losses in the timescale of a single round trip, with only a fractional congestion window reduction. RTO recovery and congestion window reset should ideally be the last resort and should ideally be used only when the entire flight is lost. However, in addition to losing an entire flight of data, the following situations can unnecessarily resort to RTO recovery with traditional TCP loss recovery algorithms <span>[<a href="#RFC5681" class="xref">RFC5681</a>]</span> <span>[<a href="#RFC6675" class="xref">RFC6675</a>]</span>:<a href="#section-1.2-1" class="pilcrow">¶</a></p>
---
> <p id="section-1.2-1">Fast recovery is the preferred form of loss recovery because it can potentially recover all losses in the timescale of a single round trip, with only a fractional congestion window reduction. RTO recovery and congestion window reset should ideally be the last resort and should ideally be used only when the entire flight is lost. However, in addition to losing an entire flight of data, the following situations can unnecessarily resort to RTO recovery with traditional TCP loss recovery algorithms <span>[<a href="#RFC5681" class="cite xref">RFC5681</a>]</span> <span>[<a href="#RFC6675" class="cite xref">RFC6675</a>]</span>:<a href="#section-1.2-1" class="pilcrow">¶</a></p>
1457c1493
<           <li id="section-1.2-2.2">Lost retransmissions. Heavy congestion or traffic policers can cause retransmissions to be lost. Lost retransmissions cause a resort to RTO recovery since DupAck counting does not detect the loss of the retransmissions. Then the slow start after RTO recovery could cause burst losses again, which severely degrades performance <span>[<a href="#POLICER16" class="xref">POLICER16</a>]</span>.<a href="#section-1.2-2.2" class="pilcrow">¶</a>
---
>           <li id="section-1.2-2.2">Lost retransmissions. Heavy congestion or traffic policers can cause retransmissions to be lost. Lost retransmissions cause a resort to RTO recovery since DupAck counting does not detect the loss of the retransmissions. Then the slow start after RTO recovery could cause burst losses again, which severely degrades performance <span>[<a href="#POLICER16" class="cite xref">POLICER16</a>]</span>.<a href="#section-1.2-2.2" class="pilcrow">¶</a>
1461c1497
<  If the reordering degree is beyond DupThresh, DupAck counting can cause a spurious fast recovery and unnecessary congestion window reduction. To mitigate the issue, Non-Congestion Robustness (NCR) for TCP <span>[<a href="#RFC4653" class="xref">RFC4653</a>]</span> increases the DupThresh from the current fixed value of three duplicate ACKs <span>[<a href="#RFC5681" class="xref">RFC5681</a>]</span> to approximate a congestion window of data having left the network.<a href="#section-1.2-2.3" class="pilcrow">¶</a>
---
>  If the reordering degree is beyond DupThresh, DupAck counting can cause a spurious fast recovery and unnecessary congestion window reduction. To mitigate the issue, Non-Congestion Robustness (NCR) for TCP <span>[<a href="#RFC4653" class="cite xref">RFC4653</a>]</span> increases the DupThresh from the current fixed value of three duplicate ACKs <span>[<a href="#RFC5681" class="cite xref">RFC5681</a>]</span> to approximate a congestion window of data having left the network.<a href="#section-1.2-2.3" class="pilcrow">¶</a>
1476c1512
<      described in BCP 14 <span>[<a href="#RFC2119" class="xref">RFC2119</a>]</span> <span>[<a href="#RFC8174" class="xref">RFC8174</a>]</span> 
---
>      described in BCP 14 <span>[<a href="#RFC2119" class="cite xref">RFC2119</a>]</span> <span>[<a href="#RFC8174" class="cite xref">RFC8174</a>]</span> 
1485c1521
< <p id="section-3-1">RACK-TLP allows senders to recover losses more effectively in all three scenarios described in the <a href="#motivation" class="xref">previous</a> section. There are two design principles behind RACK-TLP. The first principle is to detect losses via ACK events as much as possible, to repair losses at round-trip timescales. The second principle is to gently probe the network to solicit additional ACK feedback, to avoid RTO expiration and subsequent congestion window reset. At a high level, the two principles are implemented in RACK and TLP, respectively.<a href="#section-3-1" class="pilcrow">¶</a></p>
---
> <p id="section-3-1">RACK-TLP allows senders to recover losses more effectively in all three scenarios described in the <a href="#motivation" class="internal xref">previous</a> section. There are two design principles behind RACK-TLP. The first principle is to detect losses via ACK events as much as possible, to repair losses at round-trip timescales. The second principle is to gently probe the network to solicit additional ACK feedback, to avoid RTO expiration and subsequent congestion window reset. At a high level, the two principles are implemented in RACK and TLP, respectively.<a href="#section-3-1" class="pilcrow">¶</a></p>
1492c1528
<  The rationale behind RACK is that if a segment is delivered out of order, then the segments sent chronologically before that were either lost or reordered. This concept is not fundamentally different from those described in <span>[<a href="#RFC5681" class="xref">RFC5681</a>]</span>, <span>[<a href="#RFC6675" class="xref">RFC6675</a>]</span>, or <span>[<a href="#FACK" class="xref">FACK</a>]</span>. RACK's key innovation is using per-segment transmission timestamps and widely deployed SACK <span>[<a href="#RFC2018" class="xref">RFC2018</a>]</span> options to conduct time-based inferences instead of inferring losses by counting ACKs or SACKed sequences. Time-based inferences are more robust than DupAck counting approaches because they do not depend on flight size and thus are effective for application-limited traffic.<a href="#section-3.1-1" class="pilcrow">¶</a></p>
---
>  The rationale behind RACK is that if a segment is delivered out of order, then the segments sent chronologically before that were either lost or reordered. This concept is not fundamentally different from those described in <span>[<a href="#RFC5681" class="cite xref">RFC5681</a>]</span>, <span>[<a href="#RFC6675" class="cite xref">RFC6675</a>]</span>, or <span>[<a href="#FACK" class="cite xref">FACK</a>]</span>. RACK's key innovation is using per-segment transmission timestamps and widely deployed SACK <span>[<a href="#RFC2018" class="cite xref">RFC2018</a>]</span> options to conduct time-based inferences instead of inferring losses by counting ACKs or SACKed sequences. Time-based inferences are more robust than DupAck counting approaches because they do not depend on flight size and thus are effective for application-limited traffic.<a href="#section-3.1-1" class="pilcrow">¶</a></p>
1505c1541
< <p id="section-3.2-1">RACK infers losses from ACK feedback; however, in some cases, ACKs are sparse, particularly when the inflight is small or when the losses are high. In some challenging cases, the last few segments in a flight are lost. With the operations described in <span>[<a href="#RFC5681" class="xref">RFC5681</a>]</span> or <span>[<a href="#RFC6675" class="xref">RFC6675</a>]</span>, the sender's RTO would expire and reset the congestion window when, in reality, most of the flight has been delivered.<a href="#section-3.2-1" class="pilcrow">¶</a></p>
---
> <p id="section-3.2-1">RACK infers losses from ACK feedback; however, in some cases, ACKs are sparse, particularly when the inflight is small or when the losses are high. In some challenging cases, the last few segments in a flight are lost. With the operations described in <span>[<a href="#RFC5681" class="cite xref">RFC5681</a>]</span> or <span>[<a href="#RFC6675" class="cite xref">RFC6675</a>]</span>, the sender's RTO would expire and reset the congestion window when, in reality, most of the flight has been delivered.<a href="#section-3.2-1" class="pilcrow">¶</a></p>
1528c1564
< <p id="section-3.3.1-4">In the above two cases, the degree of reordering in packet distance is highly variable. This makes the DupAck counting approach ineffective, including dynamic adaptation variants as in <span>[<a href="#RFC4653" class="xref">RFC4653</a>]</span>. Instead, the degree of reordering in time difference in such cases is usually within a single round-trip time. 
---
> <p id="section-3.3.1-4">In the above two cases, the degree of reordering in packet distance is highly variable. This makes the DupAck counting approach ineffective, including dynamic adaptation variants as in <span>[<a href="#RFC4653" class="cite xref">RFC4653</a>]</span>. Instead, the degree of reordering in time difference in such cases is usually within a single round-trip time. 
1553c1589
< <div id="rule2">The RACK reordering window <span class="bcp14">SHOULD</span> adaptively increase (using the <a href="#step4alg" class="xref">algorithm</a> in <a href="#step4" class="xref">"Step 4: Update RACK reordering window"</a> below) if the sender receives a Duplicate Selective Acknowledgment (DSACK) option <span>[<a href="#RFC2883" class="xref">RFC2883</a>]</span>. Receiving a DSACK suggests the sender made a spurious retransmission, which may have been due to the reordering window being too small.<a href="#rule2" class="pilcrow">¶</a>
---
> <div id="rule2">The RACK reordering window <span class="bcp14">SHOULD</span> adaptively increase (using the <a href="#step4alg" class="internal xref">algorithm</a> in <a href="#step4" class="internal xref">"Step 4: Update RACK reordering window"</a> below) if the sender receives a Duplicate Selective Acknowledgment (DSACK) option <span>[<a href="#RFC2883" class="cite xref">RFC2883</a>]</span>. Receiving a DSACK suggests the sender made a spurious retransmission, which may have been due to the reordering window being too small.<a href="#rule2" class="pilcrow">¶</a>
1561c1597
< <p id="section-3.3.2-3">Rules <a href="#rule2" class="xref">2</a> and <a href="#rule3" class="xref">3</a> are required to adapt to reordering caused by dynamics such as the prolonged link-layer loss recovery episodes described earlier. Each increase in the reordering window requires a new round trip where the sender receives a DSACK; thus, depending on the extent of reordering, it may take multiple round trips to fully adapt.<a href="#section-3.3.2-3" class="pilcrow">¶</a></p>
---
> <p id="section-3.3.2-3">Rules <a href="#rule2" class="internal xref">2</a> and <a href="#rule3" class="internal xref">3</a> are required to adapt to reordering caused by dynamics such as the prolonged link-layer loss recovery episodes described earlier. Each increase in the reordering window requires a new round trip where the sender receives a DSACK; thus, depending on the extent of reordering, it may take multiple round trips to fully adapt.<a href="#section-3.3.2-3" class="pilcrow">¶</a></p>
1573c1609
< <p id="section-3.4-1">The following example in <a href="#fig1" class="xref">Figure 1</a> illustrates the RACK-TLP algorithm in action:<a href="#section-3.4-1" class="pilcrow">¶</a></p>
---
> <p id="section-3.4-1">The following example in <a href="#fig1" class="auto internal xref">Figure 1</a> illustrates the RACK-TLP algorithm in action:<a href="#section-3.4-1" class="pilcrow">¶</a></p>
1576c1612
<           <div class="artwork art-text alignLeft" id="section-3.4-2.1">
---
>           <div class="alignLeft art-text artwork" id="section-3.4-2.1">
1608c1644
< <p id="section-3.4-3"><a href="#fig1" class="xref">Figure 1</a> illustrates a sender sending four segments (P0, P1, P2, P3) and losing the last three segments. After two round trips, TLP sends a loss probe, retransmitting the last segment, P3, to solicit SACK feedback and restore the ACK clock (Event 3). The delivery of P3 enables RACK to infer (Event 5b) that P1 and P2 were likely lost because they were sent before P3. The sender then retransmits P1 and P2. Unfortunately, the retransmission of P1 is lost again. However, the delivery of the retransmission of P2 allows RACK to infer that the retransmission of P1 was likely lost (Event 7a); hence, P1 should be retransmitted (Event 7b). Note that <span>[<a href="#RFC5681" class="xref">RFC5681</a>]</span> mandates a principle that loss in two successive windows of data or the loss of a retransmission must be taken as two indications of congestion and therefore results in two separate congestion control reactions.<a href="#section-3.4-3" class="pilcrow">¶</a></p>
---
> <p id="section-3.4-3"><a href="#fig1" class="auto internal xref">Figure 1</a> illustrates a sender sending four segments (P0, P1, P2, P3) and losing the last three segments. After two round trips, TLP sends a loss probe, retransmitting the last segment, P3, to solicit SACK feedback and restore the ACK clock (Event 3). The delivery of P3 enables RACK to infer (Event 5b) that P1 and P2 were likely lost because they were sent before P3. The sender then retransmits P1 and P2. Unfortunately, the retransmission of P1 is lost again. However, the delivery of the retransmission of P2 allows RACK to infer that the retransmission of P1 was likely lost (Event 7a); hence, P1 should be retransmitted (Event 7b). Note that <span>[<a href="#RFC5681" class="cite xref">RFC5681</a>]</span> mandates a principle that loss in two successive windows of data or the loss of a retransmission must be taken as two indications of congestion and therefore results in two separate congestion control reactions.<a href="#section-3.4-3" class="pilcrow">¶</a></p>
1637c1673
< <p id="section-4-1">The reader is expected to be familiar with the definitions given in the TCP congestion control <span>[<a href="#RFC5681" class="xref">RFC5681</a>]</span>, selective acknowledgment <span>[<a href="#RFC2018" class="xref">RFC2018</a>]</span>, and loss recovery <span>[<a href="#RFC6675" class="xref">RFC6675</a>]</span> RFCs. RACK-TLP has the following requirements:<a href="#section-4-1" class="pilcrow">¶</a></p>
---
> <p id="section-4-1">The reader is expected to be familiar with the definitions given in the TCP congestion control <span>[<a href="#RFC5681" class="cite xref">RFC5681</a>]</span>, selective acknowledgment <span>[<a href="#RFC2018" class="cite xref">RFC2018</a>]</span>, and loss recovery <span>[<a href="#RFC6675" class="cite xref">RFC6675</a>]</span> RFCs. RACK-TLP has the following requirements:<a href="#section-4-1" class="pilcrow">¶</a></p>
1639c1675
< <li id="section-4-2.1">The connection <span class="bcp14">MUST</span> use selective acknowledgment (SACK) options <span>[<a href="#RFC2018" class="xref">RFC2018</a>]</span>, and the sender <span class="bcp14">MUST</span> keep SACK scoreboard information on a per-connection basis ("SACK scoreboard" has the same meaning here as in <span>[<a href="#RFC6675" class="xref">RFC6675</a>], <a href="https://www.rfc-editor.org/rfc/rfc6675#section-3" class="relref">Section 3</a></span>).<a href="#section-4-2.1" class="pilcrow">¶</a>
---
> <li id="section-4-2.1">The connection <span class="bcp14">MUST</span> use selective acknowledgment (SACK) options <span>[<a href="#RFC2018" class="cite xref">RFC2018</a>]</span>, and the sender <span class="bcp14">MUST</span> keep SACK scoreboard information on a per-connection basis ("SACK scoreboard" has the same meaning here as in <span>[<a href="#RFC6675" class="cite xref">RFC6675</a>], <a href="https://rfc-editor.org/rfc/rfc6675#section-3" class="relref">Section 3</a></span>).<a href="#section-4-2.1" class="pilcrow">¶</a>
1657c1693
< <p id="section-5-1">The reader is expected to be familiar with the variables SND.UNA, SND.NXT, SEG.ACK, and SEG.SEQ in <span>[<a href="#RFC0793" class="xref">RFC793</a>]</span>; Sender Maximum Segment Size (SMSS) and FlightSize in <span>[<a href="#RFC5681" class="xref">RFC5681</a>]</span>; DupThresh in <span>[<a href="#RFC6675" class="xref">RFC6675</a>]</span>; and RTO and SRTT in <span>[<a href="#RFC6298" class="xref">RFC6298</a>]</span>. A RACK-TLP implementation uses several new terms and needs to store new per-segment and per-connection state, described below.<a href="#section-5-1" class="pilcrow">¶</a></p>
---
> <p id="section-5-1">The reader is expected to be familiar with the variables SND.UNA, SND.NXT, SEG.ACK, and SEG.SEQ in <span>[<a href="#RFC0793" class="cite xref">RFC793</a>]</span>; Sender Maximum Segment Size (SMSS) and FlightSize in <span>[<a href="#RFC5681" class="cite xref">RFC5681</a>]</span>; DupThresh in <span>[<a href="#RFC6675" class="cite xref">RFC6675</a>]</span>; and RTO and SRTT in <span>[<a href="#RFC6298" class="cite xref">RFC6298</a>]</span>. A RACK-TLP implementation uses several new terms and needs to store new per-segment and per-connection state, described below.<a href="#section-5-1" class="pilcrow">¶</a></p>
1692c1728
<           <dd style="margin-left: 1.5em" id="section-5.2-2.6">The time of the last transmission of a data segment, including retransmissions, if any, with a clock granularity specified in the <a href="#requirements" class="xref">"Requirements"</a> section. A maximum value INFINITE_TS indicates an invalid timestamp that represents that the segment is not currently in flight.<a href="#section-5.2-2.6" class="pilcrow">¶</a>
---
>           <dd style="margin-left: 1.5em" id="section-5.2-2.6">The time of the last transmission of a data segment, including retransmissions, if any, with a clock granularity specified in the <a href="#requirements" class="internal xref">"Requirements"</a> section. A maximum value INFINITE_TS indicates an invalid timestamp that represents that the segment is not currently in flight.<a href="#section-5.2-2.6" class="pilcrow">¶</a>
1784c1820
< <p id="section-5.4-2">These timers augment the existing timers maintained by a sender, including the RTO timer <span>[<a href="#RFC6298" class="xref">RFC6298</a>]</span>. A RACK-TLP sender arms one of these three timers -- RACK reordering timer, TLP PTO timer, or RTO timer -- when it has unacknowledged segments in flight. The implementation can simplify managing all three timers by multiplexing a single timer among them with an additional variable to indicate the event to invoke upon the next timer expiration.<a href="#section-5.4-2" class="pilcrow">¶</a></p>
---
> <p id="section-5.4-2">These timers augment the existing timers maintained by a sender, including the RTO timer <span>[<a href="#RFC6298" class="cite xref">RFC6298</a>]</span>. A RACK-TLP sender arms one of these three timers -- RACK reordering timer, TLP PTO timer, or RTO timer -- when it has unacknowledged segments in flight. The implementation can simplify managing all three timers by multiplexing a single timer among them with an additional variable to indicate the event to invoke upon the next timer expiration.<a href="#section-5.4-2" class="pilcrow">¶</a></p>
1800,1801c1836,1837
< <div id="section-6.1-2">
< <pre class="sourcecode lang-pseudocode">
---
> <div class="lang-pseudocode sourcecode" id="section-6.1-2">
> <pre>
1822c1858
< <p id="section-6.2-2">Use the RTT measurements obtained via <span>[<a href="#RFC6298" class="xref">RFC6298</a>]</span> or <span>[<a href="#RFC7323" class="xref">RFC7323</a>]</span> to update the estimated minimum RTT in RACK.min_RTT. The sender <span class="bcp14">SHOULD</span> track a windowed min-filtered estimate of recent RTT measurements that can adapt when migrating to significantly longer paths rather than tracking a simple global minimum of all RTT measurements.<a href="#section-6.2-2" class="pilcrow">¶</a></p>
---
> <p id="section-6.2-2">Use the RTT measurements obtained via <span>[<a href="#RFC6298" class="cite xref">RFC6298</a>]</span> or <span>[<a href="#RFC7323" class="cite xref">RFC7323</a>]</span> to update the estimated minimum RTT in RACK.min_RTT. The sender <span class="bcp14">SHOULD</span> track a windowed min-filtered estimate of recent RTT measurements that can adapt when migrating to significantly longer paths rather than tracking a simple global minimum of all RTT measurements.<a href="#section-6.2-2" class="pilcrow">¶</a></p>
1832c1868
< <li id="section-6.2-6.1">The Timestamp Echo Reply field (TSecr) of the ACK's timestamp option <span>[<a href="#RFC7323" class="xref">RFC7323</a>]</span>, if available, indicates the ACK was not acknowledging the last retransmission of the segment.<a href="#section-6.2-6.1" class="pilcrow">¶</a>
---
> <li id="section-6.2-6.1">The Timestamp Echo Reply field (TSecr) of the ACK's timestamp option <span>[<a href="#RFC7323" class="cite xref">RFC7323</a>]</span>, if available, indicates the ACK was not acknowledging the last retransmission of the segment.<a href="#section-6.2-6.1" class="pilcrow">¶</a>
1841,1842c1877,1878
< <div id="section-6.2-10">
< <pre class="sourcecode lang-pseudocode">
---
> <div class="lang-pseudocode sourcecode" id="section-6.2-10">
> <pre>
1872,1874c1908,1910
< <p id="section-6.2-12">To detect reordering, the sender looks for original data segments being delivered out of order. To detect such cases, the sender tracks the highest sequence selectively or cumulatively acknowledged in the RACK.fack variable. ".fack" stands for the most "Forward ACK" (this term is adopted from <span>[<a href="#FACK" class="xref">FACK</a>]</span>). If a never-retransmitted segment that's below RACK.fack is (selectively or cumulatively) acknowledged, it has been delivered out of order. The sender sets RACK.reordering_seen to TRUE if such a segment is identified.<a href="#section-6.2-12" class="pilcrow">¶</a></p>
< <div id="section-6.2-13">
< <pre class="sourcecode lang-pseudocode">
---
> <p id="section-6.2-12">To detect reordering, the sender looks for original data segments being delivered out of order. To detect such cases, the sender tracks the highest sequence selectively or cumulatively acknowledged in the RACK.fack variable. ".fack" stands for the most "Forward ACK" (this term is adopted from <span>[<a href="#FACK" class="cite xref">FACK</a>]</span>). If a never-retransmitted segment that's below RACK.fack is (selectively or cumulatively) acknowledged, it has been delivered out of order. The sender sets RACK.reordering_seen to TRUE if such a segment is identified.<a href="#section-6.2-12" class="pilcrow">¶</a></p>
> <div class="lang-pseudocode sourcecode" id="section-6.2-13">
> <pre>
1888,1889c1924,1925
< <p id="section-6.2-15">The RACK reordering window, RACK.reo_wnd, serves as an adaptive allowance for settling time before marking a segment as lost. This step documents a detailed algorithm that follows the principles outlined in the <a href="#reordering-window-adaptation" class="xref">"Reordering Window Adaptation"</a> section.<a href="#section-6.2-15" class="pilcrow">¶</a></p>
< <p id="section-6.2-16">If no reordering has been observed based on the <a href="#step3" class="xref">previous step</a>, then one way the sender can enter fast recovery is when the number of SACKed segments matches or exceeds DupThresh (similar to <span>[<a href="#RFC6675" class="xref">RFC6675</a>]</span>). Furthermore, when no reordering has been observed, the RACK.reo_wnd is set to 0 both upon entering and during fast recovery or RTO recovery.<a href="#section-6.2-16" class="pilcrow">¶</a></p>
---
> <p id="section-6.2-15">The RACK reordering window, RACK.reo_wnd, serves as an adaptive allowance for settling time before marking a segment as lost. This step documents a detailed algorithm that follows the principles outlined in the <a href="#reordering-window-adaptation" class="internal xref">"Reordering Window Adaptation"</a> section.<a href="#section-6.2-15" class="pilcrow">¶</a></p>
> <p id="section-6.2-16">If no reordering has been observed based on the <a href="#step3" class="internal xref">previous step</a>, then one way the sender can enter fast recovery is when the number of SACKed segments matches or exceeds DupThresh (similar to <span>[<a href="#RFC6675" class="cite xref">RFC6675</a>]</span>). Furthermore, when no reordering has been observed, the RACK.reo_wnd is set to 0 both upon entering and during fast recovery or RTO recovery.<a href="#section-6.2-16" class="pilcrow">¶</a></p>
1892,1893c1928,1929
< <p id="section-6.2-19">When the reordering window is not set to 0, it starts with a conservative RACK.reo_wnd of RACK.min_RTT/4. This value was chosen because Linux TCP used the same factor in its implementation to delay Early Retransmit <span>[<a href="#RFC5827" class="xref">RFC5827</a>]</span> to reduce spurious loss detections in the presence of reordering, and experience showed this worked reasonably well <span>[<a href="#DMCG11" class="xref">DMCG11</a>]</span>.<a href="#section-6.2-19" class="pilcrow">¶</a></p>
< <p id="section-6.2-20">However, the reordering detection in the previous step, <a href="#step3" class="xref">Step 3</a>, has a self-reinforcing drawback when the reordering window is too small to cope with the actual reordering. When that happens, RACK could spuriously mark reordered segments as lost, causing them to be retransmitted. In turn, the retransmissions can prevent the necessary conditions for <a href="#step3" class="xref">Step 3</a> to detect reordering since this mechanism requires ACKs or SACKs only for segments that have never been retransmitted. In some cases, such scenarios can persist, causing RACK to continue to spuriously mark segments as lost without realizing the reordering window is too small.<a href="#section-6.2-20" class="pilcrow">¶</a></p>
---
> <p id="section-6.2-19">When the reordering window is not set to 0, it starts with a conservative RACK.reo_wnd of RACK.min_RTT/4. This value was chosen because Linux TCP used the same factor in its implementation to delay Early Retransmit <span>[<a href="#RFC5827" class="cite xref">RFC5827</a>]</span> to reduce spurious loss detections in the presence of reordering, and experience showed this worked reasonably well <span>[<a href="#DMCG11" class="cite xref">DMCG11</a>]</span>.<a href="#section-6.2-19" class="pilcrow">¶</a></p>
> <p id="section-6.2-20">However, the reordering detection in the previous step, <a href="#step3" class="internal xref">Step 3</a>, has a self-reinforcing drawback when the reordering window is too small to cope with the actual reordering. When that happens, RACK could spuriously mark reordered segments as lost, causing them to be retransmitted. In turn, the retransmissions can prevent the necessary conditions for <a href="#step3" class="internal xref">Step 3</a> to detect reordering since this mechanism requires ACKs or SACKs only for segments that have never been retransmitted. In some cases, such scenarios can persist, causing RACK to continue to spuriously mark segments as lost without realizing the reordering window is too small.<a href="#section-6.2-20" class="pilcrow">¶</a></p>
1899,1900c1935,1936
< <div id="section-6.2-25">
< <pre class="sourcecode lang-pseudocode">
---
> <div class="lang-pseudocode sourcecode" id="section-6.2-25">
> <pre>
1932,1933c1968,1969
< <div id="section-6.2-28">
< <pre class="sourcecode lang-pseudocode">
---
> <div class="lang-pseudocode sourcecode" id="section-6.2-28">
> <pre>
1940,1941c1976,1977
< <div id="section-6.2-30">
< <pre class="sourcecode lang-pseudocode">
---
> <div class="lang-pseudocode sourcecode" id="section-6.2-30">
> <pre>
1947,1948c1983,1984
< <div id="section-6.2-33">
< <pre class="sourcecode lang-pseudocode">
---
> <div class="lang-pseudocode sourcecode" id="section-6.2-33">
> <pre>
1953,1954c1989,1990
< <div id="section-6.2-35">
< <pre class="sourcecode lang-pseudocode">
---
> <div class="lang-pseudocode sourcecode" id="section-6.2-35">
> <pre>
1960,1961c1996,1997
< <div id="section-6.2-38">
< <pre class="sourcecode lang-pseudocode">
---
> <div class="lang-pseudocode sourcecode" id="section-6.2-38">
> <pre>
1993,1994c2029,2030
< <div id="section-6.3-2">
< <pre class="sourcecode lang-pseudocode">
---
> <div class="lang-pseudocode sourcecode" id="section-6.3-2">
> <pre>
2017,2018c2053,2054
< <div id="section-7.1-2">
< <pre class="sourcecode lang-pseudocode">
---
> <div class="lang-pseudocode sourcecode" id="section-7.1-2">
> <pre>
2032c2068
< The sender schedules a loss probe timeout (PTO) to transmit a segment during the normal transmission process. The sender <span class="bcp14">SHOULD</span> start or restart a loss probe PTO timer after transmitting new data (that was not itself a loss probe) or upon receiving an ACK that cumulatively acknowledges new data unless it is already in fast recovery, RTO recovery, or segments have been SACKed (i.e., RACK.segs_sacked is not zero). These conditions are excluded because they are addressed by similar mechanisms, like Limited Transmit <span>[<a href="#RFC3042" class="xref">RFC3042</a>]</span>, the RACK reordering timer, and Forward RTO-Recovery (F-RTO) <span>[<a href="#RFC5682" class="xref">RFC5682</a>]</span>.<a href="#section-7.2-1" class="pilcrow">¶</a></p>
---
> The sender schedules a loss probe timeout (PTO) to transmit a segment during the normal transmission process. The sender <span class="bcp14">SHOULD</span> start or restart a loss probe PTO timer after transmitting new data (that was not itself a loss probe) or upon receiving an ACK that cumulatively acknowledges new data unless it is already in fast recovery, RTO recovery, or segments have been SACKed (i.e., RACK.segs_sacked is not zero). These conditions are excluded because they are addressed by similar mechanisms, like Limited Transmit <span>[<a href="#RFC3042" class="cite xref">RFC3042</a>]</span>, the RACK reordering timer, and Forward RTO-Recovery (F-RTO) <span>[<a href="#RFC5682" class="cite xref">RFC5682</a>]</span>.<a href="#section-7.2-1" class="pilcrow">¶</a></p>
2035c2071
< <p id="section-7.2-4">Second, when there is no SRTT estimate available, the PTO <span class="bcp14">SHOULD</span> be 1 second. This conservative value corresponds to the RTO value when no SRTT is available, per <span>[<a href="#RFC6298" class="xref">RFC6298</a>]</span>.<a href="#section-7.2-4" class="pilcrow">¶</a></p>
---
> <p id="section-7.2-4">Second, when there is no SRTT estimate available, the PTO <span class="bcp14">SHOULD</span> be 1 second. This conservative value corresponds to the RTO value when no SRTT is available, per <span>[<a href="#RFC6298" class="cite xref">RFC6298</a>]</span>.<a href="#section-7.2-4" class="pilcrow">¶</a></p>
2039,2040c2075,2076
< <div id="section-7.2-8">
< <pre class="sourcecode lang-pseudocode">
---
> <div class="lang-pseudocode sourcecode" id="section-7.2-8">
> <pre>
2072c2108
< <p id="section-7.3-7">The sender <span class="bcp14">MUST</span> follow the RACK transmission procedures in the <a href="#upon-transmitting-a-data-segment" class="xref">"Upon Transmitting a Data Segment"</a> section upon sending either a retransmission or a new data loss probe. This is critical for detecting losses using the ACK for the loss probe.<a href="#section-7.3-7" class="pilcrow">¶</a></p>
---
> <p id="section-7.3-7">The sender <span class="bcp14">MUST</span> follow the RACK transmission procedures in the <a href="#upon-transmitting-a-data-segment" class="internal xref">"Upon Transmitting a Data Segment"</a> section upon sending either a retransmission or a new data loss probe. This is critical for detecting losses using the ACK for the loss probe.<a href="#section-7.3-7" class="pilcrow">¶</a></p>
2075,2076c2111,2112
< <div id="section-7.3-9">
< <pre class="sourcecode lang-pseudocode">
---
> <div class="lang-pseudocode sourcecode" id="section-7.3-9">
> <pre>
2115c2151
< <p id="section-7.4.1-1">If the loss probe and the ACK that acknowledges the probe are delivered successfully, RACK-TLP uses this ACK -- just as it would with any other ACK -- to detect if any segments sent prior to the probe were dropped. RACK would typically infer that any unacknowledged data segments sent before the loss probe were lost, since they were sent sufficiently far in the past (where at least one PTO has elapsed, plus one round trip for the loss probe to be ACKed). More specifically, RACK_detect_loss() (<a href="#step5" class="xref">Step 5</a>) would mark those earlier segments as lost. Then the sender would trigger a fast recovery to recover those losses.<a href="#section-7.4.1-1" class="pilcrow">¶</a></p>
---
> <p id="section-7.4.1-1">If the loss probe and the ACK that acknowledges the probe are delivered successfully, RACK-TLP uses this ACK -- just as it would with any other ACK -- to detect if any segments sent prior to the probe were dropped. RACK would typically infer that any unacknowledged data segments sent before the loss probe were lost, since they were sent sufficiently far in the past (where at least one PTO has elapsed, plus one round trip for the loss probe to be ACKed). More specifically, RACK_detect_loss() (<a href="#step5" class="internal xref">Step 5</a>) would mark those earlier segments as lost. Then the sender would trigger a fast recovery to recover those losses.<a href="#section-7.4.1-1" class="pilcrow">¶</a></p>
2123c2159
< <p id="section-7.4.2-1">If the TLP retransmission repairs all the lost in-flight sequence ranges (i.e., only the last segment in the flight was lost), the ACK for the loss probe appears to be a regular cumulative ACK, which would not normally trigger the congestion control response to this packet loss event. The following TLP recovery detection mechanism examines ACKs to detect this special case to make congestion control respond properly <span>[<a href="#RFC5681" class="xref">RFC5681</a>]</span>.<a href="#section-7.4.2-1" class="pilcrow">¶</a></p>
---
> <p id="section-7.4.2-1">If the TLP retransmission repairs all the lost in-flight sequence ranges (i.e., only the last segment in the flight was lost), the ACK for the loss probe appears to be a regular cumulative ACK, which would not normally trigger the congestion control response to this packet loss event. The following TLP recovery detection mechanism examines ACKs to detect this special case to make congestion control respond properly <span>[<a href="#RFC5681" class="cite xref">RFC5681</a>]</span>.<a href="#section-7.4.2-1" class="pilcrow">¶</a></p>
2129,2130c2165,2166
< <div id="section-7.4.2-6">
< <pre class="sourcecode lang-pseudocode">
---
> <div class="lang-pseudocode sourcecode" id="section-7.4.2-6">
> <pre>
2156c2192
< <p id="section-8-1">The RACK reordering timer, the TLP PTO timer, the RTO, and Zero Window Probe (ZWP) timer <span>[<a href="#RFC0793" class="xref">RFC793</a>]</span> are mutually exclusive and are used in different scenarios. When arming a RACK reordering timer or TLP PTO timer, the sender <span class="bcp14">SHOULD</span> cancel any other pending timers. An implementation is expected to have one timer with an additional state variable indicating the type of the timer.<a href="#section-8-1" class="pilcrow">¶</a></p>
---
> <p id="section-8-1">The RACK reordering timer, the TLP PTO timer, the RTO, and Zero Window Probe (ZWP) timer <span>[<a href="#RFC0793" class="cite xref">RFC793</a>]</span> are mutually exclusive and are used in different scenarios. When arming a RACK reordering timer or TLP PTO timer, the sender <span class="bcp14">SHOULD</span> cancel any other pending timers. An implementation is expected to have one timer with an additional state variable indicating the type of the timer.<a href="#section-8-1" class="pilcrow">¶</a></p>
2171c2207
< <li id="section-9.1-2.1">Packet drops at the end of an application data flight: Consider a sender that transmits an application-limited flight of three data segments (P1, P2, P3), and P1 and P3 are lost. Suppose the transmission of each segment is at least RACK.reo_wnd after the transmission of the previous segment. RACK will mark P1 as lost when the SACK of P2 is received, and this will trigger the retransmission of P1 as R1. When R1 is cumulatively acknowledged, RACK will mark P3 as lost, and the sender will retransmit P3 as R3. This example illustrates how RACK is able to repair certain drops at the tail of a transaction without an RTO recovery. Notice that neither the conventional duplicate ACK threshold <span>[<a href="#RFC5681" class="xref">RFC5681</a>]</span>, nor the loss recovery algorithm <span>[<a href="#RFC6675" class="xref">RFC6675</a>]</span>, nor the Forward Acknowledgment <span>[<a href="#FACK" class="xref">FACK</a>]</span> algorithm can detect such losses because of the required segment or sequence count.<a href="#section-9.1-2.1" class="pilcrow">¶</a>
---
> <li id="section-9.1-2.1">Packet drops at the end of an application data flight: Consider a sender that transmits an application-limited flight of three data segments (P1, P2, P3), and P1 and P3 are lost. Suppose the transmission of each segment is at least RACK.reo_wnd after the transmission of the previous segment. RACK will mark P1 as lost when the SACK of P2 is received, and this will trigger the retransmission of P1 as R1. When R1 is cumulatively acknowledged, RACK will mark P3 as lost, and the sender will retransmit P3 as R3. This example illustrates how RACK is able to repair certain drops at the tail of a transaction without an RTO recovery. Notice that neither the conventional duplicate ACK threshold <span>[<a href="#RFC5681" class="cite xref">RFC5681</a>]</span>, nor the loss recovery algorithm <span>[<a href="#RFC6675" class="cite xref">RFC6675</a>]</span>, nor the Forward Acknowledgment <span>[<a href="#FACK" class="cite xref">FACK</a>]</span> algorithm can detect such losses because of the required segment or sequence count.<a href="#section-9.1-2.1" class="pilcrow">¶</a>
2173c2209
<           <li id="section-9.1-2.2">Lost retransmission: Consider a flight of three data segments (P1, P2, P3) that are sent; P1 and P2 are dropped. Suppose the transmission of each segment is at least RACK.reo_wnd after the transmission of the previous segment. When P3 is SACKed, RACK will mark P1 and P2 as lost, and they will be retransmitted as R1 and R2. Suppose R1 is lost again but R2 is SACKed; RACK will mark R1 as lost and trigger retransmission again.  Again, neither the conventional three-duplicate ACK threshold approach, nor the loss recovery algorithm <span>[<a href="#RFC6675" class="xref">RFC6675</a>]</span>, nor the Forward Acknowledgment <span>[<a href="#FACK" class="xref">FACK</a>]</span> algorithm can detect such losses. And such a lost retransmission can happen when TCP is being rate-limited, particularly by token bucket policers with a large bucket depth and low rate limit; in such cases, retransmissions are often lost repeatedly because standard congestion control requires multiple round trips to reduce the rate below the policed rate.<a href="#section-9.1-2.2" class="pilcrow">¶</a>
---
>           <li id="section-9.1-2.2">Lost retransmission: Consider a flight of three data segments (P1, P2, P3) that are sent; P1 and P2 are dropped. Suppose the transmission of each segment is at least RACK.reo_wnd after the transmission of the previous segment. When P3 is SACKed, RACK will mark P1 and P2 as lost, and they will be retransmitted as R1 and R2. Suppose R1 is lost again but R2 is SACKed; RACK will mark R1 as lost and trigger retransmission again.  Again, neither the conventional three-duplicate ACK threshold approach, nor the loss recovery algorithm <span>[<a href="#RFC6675" class="cite xref">RFC6675</a>]</span>, nor the Forward Acknowledgment <span>[<a href="#FACK" class="cite xref">FACK</a>]</span> algorithm can detect such losses. And such a lost retransmission can happen when TCP is being rate-limited, particularly by token bucket policers with a large bucket depth and low rate limit; in such cases, retransmissions are often lost repeatedly because standard congestion control requires multiple round trips to reduce the rate below the policed rate.<a href="#section-9.1-2.2" class="pilcrow">¶</a>
2179,2180c2215,2216
< <p id="section-9.1-4">RACK-TLP works more efficiently with TCP Segmentation Offload (TSO) compared to DupAck counting. RACK always marks the entire TSO aggregate as lost because the segments in the same TSO aggregate have the same transmission timestamp. By contrast, the algorithms based on sequence counting (e.g., <span>[<a href="#RFC6675" class="xref">RFC6675</a>]</span>, <span>[<a href="#RFC5681" class="xref">RFC5681</a>]</span>) may mark only a subset of segments in the TSO aggregate as lost, forcing the stack to perform expensive fragmentation of the TSO aggregate or to selectively tag individual segments as lost in the scoreboard.<a href="#section-9.1-4" class="pilcrow">¶</a></p>
< <p id="section-9.1-5">The main drawback of RACK-TLP is the additional state required compared to DupAck counting. RACK requires the sender to record the transmission time of each segment sent at a clock granularity that is finer than 1/4 of the minimum RTT of the connection. TCP implementations that already record this for RTT estimation do not require any new per-packet state. But implementations that are not yet recording segment transmission times will need to add per-packet internal state (expected to be either 4 or 8 octets per segment or TSO aggregate) to track transmission times. In contrast, the loss detection approach described in <span>[<a href="#RFC6675" class="xref">RFC6675</a>]</span> does not require any per-packet state beyond the SACK scoreboard; this is particularly useful on ultra-low RTT networks where the RTT may be less than the sender TCP clock granularity (e.g., inside data centers). Another disadvantage is that the reordering timer may expire prematurely (like any other retransmission timer) and cause higher spurious retransmissions, especially if DSACK is not supported.<a href="#section-9.1-5" class="pilcrow">¶</a></p>
---
> <p id="section-9.1-4">RACK-TLP works more efficiently with TCP Segmentation Offload (TSO) compared to DupAck counting. RACK always marks the entire TSO aggregate as lost because the segments in the same TSO aggregate have the same transmission timestamp. By contrast, the algorithms based on sequence counting (e.g., <span>[<a href="#RFC6675" class="cite xref">RFC6675</a>]</span>, <span>[<a href="#RFC5681" class="cite xref">RFC5681</a>]</span>) may mark only a subset of segments in the TSO aggregate as lost, forcing the stack to perform expensive fragmentation of the TSO aggregate or to selectively tag individual segments as lost in the scoreboard.<a href="#section-9.1-4" class="pilcrow">¶</a></p>
> <p id="section-9.1-5">The main drawback of RACK-TLP is the additional state required compared to DupAck counting. RACK requires the sender to record the transmission time of each segment sent at a clock granularity that is finer than 1/4 of the minimum RTT of the connection. TCP implementations that already record this for RTT estimation do not require any new per-packet state. But implementations that are not yet recording segment transmission times will need to add per-packet internal state (expected to be either 4 or 8 octets per segment or TSO aggregate) to track transmission times. In contrast, the loss detection approach described in <span>[<a href="#RFC6675" class="cite xref">RFC6675</a>]</span> does not require any per-packet state beyond the SACK scoreboard; this is particularly useful on ultra-low RTT networks where the RTT may be less than the sender TCP clock granularity (e.g., inside data centers). Another disadvantage is that the reordering timer may expire prematurely (like any other retransmission timer) and cause higher spurious retransmissions, especially if DSACK is not supported.<a href="#section-9.1-5" class="pilcrow">¶</a></p>
2188,2190c2224,2226
< <p id="section-9.2-1">The primary motivation of RACK-TLP is to provide a general alternative to some of the standard loss recovery algorithms <span>[<a href="#RFC5681" class="xref">RFC5681</a>]</span> <span>[<a href="#RFC6675" class="xref">RFC6675</a>]</span> <span>[<a href="#RFC5827" class="xref">RFC5827</a>]</span> <span>[<a href="#RFC4653" class="xref">RFC4653</a>]</span>. In particular, the SACK loss recovery algorithm for TCP <span>[<a href="#RFC6675" class="xref">RFC6675</a>]</span> is not designed to handle lost retransmissions, so its NextSeg() does not work for lost retransmissions, and it does not specify the corresponding required additional congestion response. Therefore, the algorithm <span>[<a href="#RFC6675" class="xref">RFC6675</a>]</span> <span class="bcp14">MUST NOT</span> be used with RACK-TLP; instead, a modified recovery algorithm that carefully addresses such a case is needed.<a href="#section-9.2-1" class="pilcrow">¶</a></p>
< <p id="section-9.2-2">The Early Retransmit mechanism <span>[<a href="#RFC5827" class="xref">RFC5827</a>]</span> and NCR for TCP <span>[<a href="#RFC4653" class="xref">RFC4653</a>]</span> dynamically adjust the duplicate ACK threshold based on the current or previous flight sizes. RACK-TLP takes a different approach by using a time-based reordering window. RACK-TLP can be seen as an extended Early Retransmit <span>[<a href="#RFC5827" class="xref">RFC5827</a>]</span> without a FlightSize limit but with an additional reordering window. <span>[<a href="#FACK" class="xref">FACK</a>]</span> considers an original segment to be lost when its sequence range is sufficiently far below the highest SACKed sequence. In some sense, RACK-TLP can be seen as a generalized form of FACK that operates in time space instead of sequence space, enabling it to better handle reordering, application-limited traffic, and lost retransmissions.<a href="#section-9.2-2" class="pilcrow">¶</a></p>
< <p id="section-9.2-3">RACK-TLP is compatible with the standard RTO <span>[<a href="#RFC6298" class="xref">RFC6298</a>]</span>, RTO Restart <span>[<a href="#RFC7765" class="xref">RFC7765</a>]</span>, F-RTO <span>[<a href="#RFC5682" class="xref">RFC5682</a>]</span>, and Eifel algorithms <span>[<a href="#RFC3522" class="xref">RFC3522</a>]</span>. This is because RACK-TLP only detects loss by using ACK events. It neither changes the RTO timer calculation nor detects spurious RTOs. RACK-TLP slightly changes the behavior of <span>[<a href="#RFC6298" class="xref">RFC6298</a>]</span> by preceding the RTO with a TLP and reducing potential spurious retransmissions after RTO.<a href="#section-9.2-3" class="pilcrow">¶</a></p>
---
> <p id="section-9.2-1">The primary motivation of RACK-TLP is to provide a general alternative to some of the standard loss recovery algorithms <span>[<a href="#RFC5681" class="cite xref">RFC5681</a>]</span> <span>[<a href="#RFC6675" class="cite xref">RFC6675</a>]</span> <span>[<a href="#RFC5827" class="cite xref">RFC5827</a>]</span> <span>[<a href="#RFC4653" class="cite xref">RFC4653</a>]</span>. In particular, the SACK loss recovery algorithm for TCP <span>[<a href="#RFC6675" class="cite xref">RFC6675</a>]</span> is not designed to handle lost retransmissions, so its NextSeg() does not work for lost retransmissions, and it does not specify the corresponding required additional congestion response. Therefore, the algorithm <span>[<a href="#RFC6675" class="cite xref">RFC6675</a>]</span> <span class="bcp14">MUST NOT</span> be used with RACK-TLP; instead, a modified recovery algorithm that carefully addresses such a case is needed.<a href="#section-9.2-1" class="pilcrow">¶</a></p>
> <p id="section-9.2-2">The Early Retransmit mechanism <span>[<a href="#RFC5827" class="cite xref">RFC5827</a>]</span> and NCR for TCP <span>[<a href="#RFC4653" class="cite xref">RFC4653</a>]</span> dynamically adjust the duplicate ACK threshold based on the current or previous flight sizes. RACK-TLP takes a different approach by using a time-based reordering window. RACK-TLP can be seen as an extended Early Retransmit <span>[<a href="#RFC5827" class="cite xref">RFC5827</a>]</span> without a FlightSize limit but with an additional reordering window. <span>[<a href="#FACK" class="cite xref">FACK</a>]</span> considers an original segment to be lost when its sequence range is sufficiently far below the highest SACKed sequence. In some sense, RACK-TLP can be seen as a generalized form of FACK that operates in time space instead of sequence space, enabling it to better handle reordering, application-limited traffic, and lost retransmissions.<a href="#section-9.2-2" class="pilcrow">¶</a></p>
> <p id="section-9.2-3">RACK-TLP is compatible with the standard RTO <span>[<a href="#RFC6298" class="cite xref">RFC6298</a>]</span>, RTO Restart <span>[<a href="#RFC7765" class="cite xref">RFC7765</a>]</span>, F-RTO <span>[<a href="#RFC5682" class="cite xref">RFC5682</a>]</span>, and Eifel algorithms <span>[<a href="#RFC3522" class="cite xref">RFC3522</a>]</span>. This is because RACK-TLP only detects loss by using ACK events. It neither changes the RTO timer calculation nor detects spurious RTOs. RACK-TLP slightly changes the behavior of <span>[<a href="#RFC6298" class="cite xref">RFC6298</a>]</span> by preceding the RTO with a TLP and reducing potential spurious retransmissions after RTO.<a href="#section-9.2-3" class="pilcrow">¶</a></p>
2198c2234
< <p id="section-9.3-1">RACK-TLP intentionally decouples loss detection from congestion control. RACK-TLP only detects losses; it does not modify the congestion control algorithm <span>[<a href="#RFC5681" class="xref">RFC5681</a>]</span> <span>[<a href="#RFC6937" class="xref">RFC6937</a>]</span>. A segment marked as lost by RACK-TLP <span class="bcp14">MUST NOT</span> be retransmitted until congestion control deems this appropriate. As mentioned in the paragraph following <a href="#fig1" class="xref">Figure 1</a> (<a href="#fig1desc" class="xref">Section 3.4, Paragraph 3</a>), <span>[<a href="#RFC5681" class="xref">RFC5681</a>]</span> mandates a principle that loss in two successive windows of data or the loss of a retransmission must be taken as two indications of congestion and therefore trigger two separate reactions. The Proportional Rate Reduction (PRR) algorithm <span>[<a href="#RFC6937" class="xref">RFC6937</a>]</span> is <span class="bcp14">RECOMMENDED</span> for the specific congestion control actions taken upon the losses detected by RACK-TLP. 
---
> <p id="section-9.3-1">RACK-TLP intentionally decouples loss detection from congestion control. RACK-TLP only detects losses; it does not modify the congestion control algorithm <span>[<a href="#RFC5681" class="cite xref">RFC5681</a>]</span> <span>[<a href="#RFC6937" class="cite xref">RFC6937</a>]</span>. A segment marked as lost by RACK-TLP <span class="bcp14">MUST NOT</span> be retransmitted until congestion control deems this appropriate. As mentioned in the paragraph following <a href="#fig1" class="auto internal xref">Figure 1</a> (<a href="#fig1desc" class="auto internal xref">Section 3.4, Paragraph 3</a>), <span>[<a href="#RFC5681" class="cite xref">RFC5681</a>]</span> mandates a principle that loss in two successive windows of data or the loss of a retransmission must be taken as two indications of congestion and therefore trigger two separate reactions. The Proportional Rate Reduction (PRR) algorithm <span>[<a href="#RFC6937" class="cite xref">RFC6937</a>]</span> is <span class="bcp14">RECOMMENDED</span> for the specific congestion control actions taken upon the losses detected by RACK-TLP. 
2200c2236
< In the absence of PRR <span>[<a href="#RFC6937" class="xref">RFC6937</a>]</span>, when RACK-TLP detects a lost retransmission, the congestion control <span class="bcp14">MUST</span> trigger an additional congestion response per the aforementioned principle in <span>[<a href="#RFC5681" class="xref">RFC5681</a>]</span>. If multiple original transmissions or retransmissions were lost in a window, the congestion control specified in <span>[<a href="#RFC5681" class="xref">RFC5681</a>]</span> only reacts once per window. The congestion control implementer is advised to carefully consider this subtle situation introduced by RACK-TLP.<a href="#section-9.3-1" class="pilcrow">¶</a></p>
---
> In the absence of PRR <span>[<a href="#RFC6937" class="cite xref">RFC6937</a>]</span>, when RACK-TLP detects a lost retransmission, the congestion control <span class="bcp14">MUST</span> trigger an additional congestion response per the aforementioned principle in <span>[<a href="#RFC5681" class="cite xref">RFC5681</a>]</span>. If multiple original transmissions or retransmissions were lost in a window, the congestion control specified in <span>[<a href="#RFC5681" class="cite xref">RFC5681</a>]</span> only reacts once per window. The congestion control implementer is advised to carefully consider this subtle situation introduced by RACK-TLP.<a href="#section-9.3-1" class="pilcrow">¶</a></p>
2206,2207c2242,2243
< <p id="section-9.3-6">With RACK-TLP, a sender would send the TLP after 2*RTT and get a DupAck, enabling RACK to detect the losses and trigger fast recovery. If the sender implements Proportional Rate Reduction <span>[<a href="#RFC6937" class="xref">RFC6937</a>]</span>, it would slow start to retransmit the remaining 9 lost segments since the number of segments in flight (0) is lower than the slow start threshold (10). The slow start would again take four round trips (1 + 2 + 4 + 3 = 10) to retransmit all the lost segments. The recovery latency would be 2*RTT + 4*RTT, with an ending cwnd set to the slow-start threshold of 10 segments.<a href="#section-9.3-6" class="pilcrow">¶</a></p>
< <p id="section-9.3-7">The difference in recovery latency (RTO + 4*RTT vs 6*RTT) can be significant if the RTT is much smaller than the minimum RTO (1 second in <span>[<a href="#RFC6298" class="xref">RFC6298</a>]</span>) or if the RTT is large. The former case can happen in local area networks, data center networks, or content distribution networks with deep deployments. The latter case can happen in developing regions with highly congested and/or high-latency networks.<a href="#section-9.3-7" class="pilcrow">¶</a></p>
---
> <p id="section-9.3-6">With RACK-TLP, a sender would send the TLP after 2*RTT and get a DupAck, enabling RACK to detect the losses and trigger fast recovery. If the sender implements Proportional Rate Reduction <span>[<a href="#RFC6937" class="cite xref">RFC6937</a>]</span>, it would slow start to retransmit the remaining 9 lost segments since the number of segments in flight (0) is lower than the slow start threshold (10). The slow start would again take four round trips (1 + 2 + 4 + 3 = 10) to retransmit all the lost segments. The recovery latency would be 2*RTT + 4*RTT, with an ending cwnd set to the slow-start threshold of 10 segments.<a href="#section-9.3-6" class="pilcrow">¶</a></p>
> <p id="section-9.3-7">The difference in recovery latency (RTO + 4*RTT vs 6*RTT) can be significant if the RTT is much smaller than the minimum RTO (1 second in <span>[<a href="#RFC6298" class="cite xref">RFC6298</a>]</span>) or if the RTT is large. The former case can happen in local area networks, data center networks, or content distribution networks with deep deployments. The latter case can happen in developing regions with highly congested and/or high-latency networks.<a href="#section-9.3-7" class="pilcrow">¶</a></p>
2224c2260
< <p id="section-9.5-1">RACK-TLP can be implemented in other transport protocols (e.g., <span>[<a href="#I-D.ietf-quic-recovery" class="xref">QUIC-LR</a>]</span>). The <span>[<a href="#SPROUT" class="xref">SPROUT</a>]</span> loss detection algorithm was also independently designed to use a 10 ms reordering window to improve its loss detection similar to RACK.<a href="#section-9.5-1" class="pilcrow">¶</a></p>
---
> <p id="section-9.5-1">RACK-TLP can be implemented in other transport protocols (e.g., <span>[<a href="#I-D.ietf-quic-recovery" class="cite xref">QUIC-LR</a>]</span>). The <span>[<a href="#SPROUT" class="cite xref">SPROUT</a>]</span> loss detection algorithm was also independently designed to use a 10 ms reordering window to improve its loss detection similar to RACK.<a href="#section-9.5-1" class="pilcrow">¶</a></p>
2234,2235c2270,2271
< <p id="section-10-1">RACK-TLP algorithm behavior is based on information conveyed in SACK options, so it has security considerations similar to those described in the Security Considerations section of <span>[<a href="#RFC6675" class="xref">RFC6675</a>]</span>.<a href="#section-10-1" class="pilcrow">¶</a></p>
< <p id="section-10-2">Additionally, RACK-TLP has a lower risk profile than the loss recovery algorithm <span>[<a href="#RFC6675" class="xref">RFC6675</a>]</span> because it is not vulnerable to ACK-splitting attacks <span>[<a href="#SCWA99" class="xref">SCWA99</a>]</span>: for an MSS-sized segment sent, the receiver or the attacker might send MSS ACKs that selectively or cumulatively acknowledge one additional byte per ACK. This would not fool RACK. In such a scenario, RACK.xmit_ts would not advance because all the sequence ranges within the segment were transmitted at the same time and thus carry the same transmission timestamp. In other words, SACKing only one byte of a segment or SACKing the segment in entirety have the same effect with RACK.<a href="#section-10-2" class="pilcrow">¶</a></p>
---
> <p id="section-10-1">RACK-TLP algorithm behavior is based on information conveyed in SACK options, so it has security considerations similar to those described in the Security Considerations section of <span>[<a href="#RFC6675" class="cite xref">RFC6675</a>]</span>.<a href="#section-10-1" class="pilcrow">¶</a></p>
> <p id="section-10-2">Additionally, RACK-TLP has a lower risk profile than the loss recovery algorithm <span>[<a href="#RFC6675" class="cite xref">RFC6675</a>]</span> because it is not vulnerable to ACK-splitting attacks <span>[<a href="#SCWA99" class="cite xref">SCWA99</a>]</span>: for an MSS-sized segment sent, the receiver or the attacker might send MSS ACKs that selectively or cumulatively acknowledge one additional byte per ACK. This would not fool RACK. In such a scenario, RACK.xmit_ts would not advance because all the sequence ranges within the segment were transmitted at the same time and thus carry the same transmission timestamp. In other words, SACKing only one byte of a segment or SACKing the segment in entirety have the same effect with RACK.<a href="#section-10-2" class="pilcrow">¶</a></p>
2257c2293
< <span class="refAuthor">Mathis, M.</span><span class="refAuthor">, Mahdavi, J.</span><span class="refAuthor">, Floyd, S.</span><span class="refAuthor">, and A. Romanow</span>, <span class="refTitle">"TCP Selective Acknowledgment Options"</span>, <span class="seriesInfo">RFC 2018</span>, <span class="seriesInfo">DOI 10.17487/RFC2018</span>, <time datetime="1996-10" class="refDate">October 1996</time>, <span>&lt;<a href="https://www.rfc-editor.org/info/rfc2018">https://www.rfc-editor.org/info/rfc2018</a>&gt;</span>. </dd>
---
> <span class="refAuthor">Mathis, M.</span>, <span class="refAuthor">Mahdavi, J.</span>, <span class="refAuthor">Floyd, S.</span>, and <span class="refAuthor">A. Romanow</span>, <span class="refTitle">"TCP Selective Acknowledgment Options"</span>, <span class="seriesInfo">RFC 2018</span>, <span class="seriesInfo">DOI 10.17487/RFC2018</span>, <time datetime="1996-10" class="refDate">October 1996</time>, <span>&lt;<a href="https://www.rfc-editor.org/info/rfc2018">https://www.rfc-editor.org/info/rfc2018</a>&gt;</span>. </dd>
2265c2301
< <span class="refAuthor">Floyd, S.</span><span class="refAuthor">, Mahdavi, J.</span><span class="refAuthor">, Mathis, M.</span><span class="refAuthor">, and M. Podolsky</span>, <span class="refTitle">"An Extension to the Selective Acknowledgement (SACK) Option for TCP"</span>, <span class="seriesInfo">RFC 2883</span>, <span class="seriesInfo">DOI 10.17487/RFC2883</span>, <time datetime="2000-07" class="refDate">July 2000</time>, <span>&lt;<a href="https://www.rfc-editor.org/info/rfc2883">https://www.rfc-editor.org/info/rfc2883</a>&gt;</span>. </dd>
---
> <span class="refAuthor">Floyd, S.</span>, <span class="refAuthor">Mahdavi, J.</span>, <span class="refAuthor">Mathis, M.</span>, and <span class="refAuthor">M. Podolsky</span>, <span class="refTitle">"An Extension to the Selective Acknowledgement (SACK) Option for TCP"</span>, <span class="seriesInfo">RFC 2883</span>, <span class="seriesInfo">DOI 10.17487/RFC2883</span>, <time datetime="2000-07" class="refDate">July 2000</time>, <span>&lt;<a href="https://www.rfc-editor.org/info/rfc2883">https://www.rfc-editor.org/info/rfc2883</a>&gt;</span>. </dd>
2269c2305
< <span class="refAuthor">Allman, M.</span><span class="refAuthor">, Paxson, V.</span><span class="refAuthor">, and E. Blanton</span>, <span class="refTitle">"TCP Congestion Control"</span>, <span class="seriesInfo">RFC 5681</span>, <span class="seriesInfo">DOI 10.17487/RFC5681</span>, <time datetime="2009-09" class="refDate">September 2009</time>, <span>&lt;<a href="https://www.rfc-editor.org/info/rfc5681">https://www.rfc-editor.org/info/rfc5681</a>&gt;</span>. </dd>
---
> <span class="refAuthor">Allman, M.</span>, <span class="refAuthor">Paxson, V.</span>, and <span class="refAuthor">E. Blanton</span>, <span class="refTitle">"TCP Congestion Control"</span>, <span class="seriesInfo">RFC 5681</span>, <span class="seriesInfo">DOI 10.17487/RFC5681</span>, <time datetime="2009-09" class="refDate">September 2009</time>, <span>&lt;<a href="https://www.rfc-editor.org/info/rfc5681">https://www.rfc-editor.org/info/rfc5681</a>&gt;</span>. </dd>
2273c2309
< <span class="refAuthor">Paxson, V.</span><span class="refAuthor">, Allman, M.</span><span class="refAuthor">, Chu, J.</span><span class="refAuthor">, and M. Sargent</span>, <span class="refTitle">"Computing TCP's Retransmission Timer"</span>, <span class="seriesInfo">RFC 6298</span>, <span class="seriesInfo">DOI 10.17487/RFC6298</span>, <time datetime="2011-06" class="refDate">June 2011</time>, <span>&lt;<a href="https://www.rfc-editor.org/info/rfc6298">https://www.rfc-editor.org/info/rfc6298</a>&gt;</span>. </dd>
---
> <span class="refAuthor">Paxson, V.</span>, <span class="refAuthor">Allman, M.</span>, <span class="refAuthor">Chu, J.</span>, and <span class="refAuthor">M. Sargent</span>, <span class="refTitle">"Computing TCP's Retransmission Timer"</span>, <span class="seriesInfo">RFC 6298</span>, <span class="seriesInfo">DOI 10.17487/RFC6298</span>, <time datetime="2011-06" class="refDate">June 2011</time>, <span>&lt;<a href="https://www.rfc-editor.org/info/rfc6298">https://www.rfc-editor.org/info/rfc6298</a>&gt;</span>. </dd>
2277c2313
< <span class="refAuthor">Blanton, E.</span><span class="refAuthor">, Allman, M.</span><span class="refAuthor">, Wang, L.</span><span class="refAuthor">, Jarvinen, I.</span><span class="refAuthor">, Kojo, M.</span><span class="refAuthor">, and Y. Nishida</span>, <span class="refTitle">"A Conservative Loss Recovery Algorithm Based on Selective Acknowledgment (SACK) for TCP"</span>, <span class="seriesInfo">RFC 6675</span>, <span class="seriesInfo">DOI 10.17487/RFC6675</span>, <time datetime="2012-08" class="refDate">August 2012</time>, <span>&lt;<a href="https://www.rfc-editor.org/info/rfc6675">https://www.rfc-editor.org/info/rfc6675</a>&gt;</span>. </dd>
---
> <span class="refAuthor">Blanton, E.</span>, <span class="refAuthor">Allman, M.</span>, <span class="refAuthor">Wang, L.</span>, <span class="refAuthor">Jarvinen, I.</span>, <span class="refAuthor">Kojo, M.</span>, and <span class="refAuthor">Y. Nishida</span>, <span class="refTitle">"A Conservative Loss Recovery Algorithm Based on Selective Acknowledgment (SACK) for TCP"</span>, <span class="seriesInfo">RFC 6675</span>, <span class="seriesInfo">DOI 10.17487/RFC6675</span>, <time datetime="2012-08" class="refDate">August 2012</time>, <span>&lt;<a href="https://www.rfc-editor.org/info/rfc6675">https://www.rfc-editor.org/info/rfc6675</a>&gt;</span>. </dd>
2281c2317
< <span class="refAuthor">Borman, D.</span><span class="refAuthor">, Braden, B.</span><span class="refAuthor">, Jacobson, V.</span><span class="refAuthor">, and R. Scheffenegger, Ed.</span>, <span class="refTitle">"TCP Extensions for High Performance"</span>, <span class="seriesInfo">RFC 7323</span>, <span class="seriesInfo">DOI 10.17487/RFC7323</span>, <time datetime="2014-09" class="refDate">September 2014</time>, <span>&lt;<a href="https://www.rfc-editor.org/info/rfc7323">https://www.rfc-editor.org/info/rfc7323</a>&gt;</span>. </dd>
---
> <span class="refAuthor">Borman, D.</span>, <span class="refAuthor">Braden, B.</span>, <span class="refAuthor">Jacobson, V.</span>, and <span class="refAuthor">R. Scheffenegger, Ed.</span>, <span class="refTitle">"TCP Extensions for High Performance"</span>, <span class="seriesInfo">RFC 7323</span>, <span class="seriesInfo">DOI 10.17487/RFC7323</span>, <time datetime="2014-09" class="refDate">September 2014</time>, <span>&lt;<a href="https://www.rfc-editor.org/info/rfc7323">https://www.rfc-editor.org/info/rfc7323</a>&gt;</span>. </dd>
2300c2336
< <span class="refAuthor">Dukkipati, N.</span><span class="refAuthor">, Matthis, M.</span><span class="refAuthor">, Cheng, Y.</span><span class="refAuthor">, and M. Ghobadi</span>, <span class="refTitle">"Proportional Rate Reduction for TCP"</span>, <span class="seriesInfo">Proceedings of the 2011 ACM SIGCOMM Conference on Internet Measurement Conference pp. 155-170</span>, <span class="seriesInfo">DOI 10.1145/2068816.2068832</span>, <time datetime="2011-11" class="refDate">November 2011</time>, <span>&lt;<a href="https://doi.org/10.1145/2068816.2068832">https://doi.org/10.1145/2068816.2068832</a>&gt;</span>. </dd>
---
> <span class="refAuthor">Dukkipati, N.</span>, <span class="refAuthor">Matthis, M.</span>, <span class="refAuthor">Cheng, Y.</span>, and <span class="refAuthor">M. Ghobadi</span>, <span class="refTitle">"Proportional Rate Reduction for TCP"</span>, <span class="seriesInfo">Proceedings of the 2011 ACM SIGCOMM Conference on Internet Measurement Conference pp. 155-170</span>, <span class="seriesInfo">DOI 10.1145/2068816.2068832</span>, <time datetime="2011-11" class="refDate">November 2011</time>, <span>&lt;<a href="https://doi.org/10.1145/2068816.2068832">https://doi.org/10.1145/2068816.2068832</a>&gt;</span>. </dd>
2304c2340
< <span class="refAuthor">Mathis, M.</span><span class="refAuthor"> and J. Mahdavi</span>, <span class="refTitle">"Forward acknowledgement: refining TCP congestion control"</span>, <span class="seriesInfo">ACM SIGCOMM Computer Communication Review Volume 26, Issue 4</span>, <span class="seriesInfo">DOI 10.1145/248157.248181</span>, <time datetime="1996-08" class="refDate">August 1996</time>, <span>&lt;<a href="https://doi.org/10.1145/248157.248181">https://doi.org/10.1145/248157.248181</a>&gt;</span>. </dd>
---
> <span class="refAuthor">Mathis, M.</span> and <span class="refAuthor">J. Mahdavi</span>, <span class="refTitle">"Forward acknowledgement: refining TCP congestion control"</span>, <span class="seriesInfo">ACM SIGCOMM Computer Communication Review Volume 26, Issue 4</span>, <span class="seriesInfo">DOI 10.1145/248157.248181</span>, <time datetime="1996-08" class="refDate">August 1996</time>, <span>&lt;<a href="https://doi.org/10.1145/248157.248181">https://doi.org/10.1145/248157.248181</a>&gt;</span>. </dd>
2308c2344
< <span class="refAuthor">Flach, T.</span><span class="refAuthor">, Papageorge, P.</span><span class="refAuthor">, Terzis, A.</span><span class="refAuthor">, Pedrosa, L.</span><span class="refAuthor">, Cheng, Y.</span><span class="refAuthor">, Karim, T.</span><span class="refAuthor">, Katz-Bassett, E.</span><span class="refAuthor">, and R. Govindan</span>, <span class="refTitle">"An Internet-Wide Analysis of Traffic Policing"</span>, <span class="refContent">Proceedings of the 2016 ACM SIGCOMM Conference pp. 468-482</span>, <span class="seriesInfo">DOI 10.1145/2934872.2934873</span>, <time datetime="2016-08" class="refDate">August 2016</time>, <span>&lt;<a href="https://doi.org/10.1145/2934872.2934873">https://doi.org/10.1145/2934872.2934873</a>&gt;</span>. </dd>
---
> <span class="refAuthor">Flach, T.</span>, <span class="refAuthor">Papageorge, P.</span>, <span class="refAuthor">Terzis, A.</span>, <span class="refAuthor">Pedrosa, L.</span>, <span class="refAuthor">Cheng, Y.</span>, <span class="refAuthor">Karim, T.</span>, <span class="refAuthor">Katz-Bassett, E.</span>, and <span class="refAuthor">R. Govindan</span>, <span class="refTitle">"An Internet-Wide Analysis of Traffic Policing"</span>, <span class="refContent">Proceedings of the 2016 ACM SIGCOMM Conference pp. 468-482</span>, <span class="seriesInfo">DOI 10.1145/2934872.2934873</span>, <time datetime="2016-08" class="refDate">August 2016</time>, <span>&lt;<a href="https://doi.org/10.1145/2934872.2934873">https://doi.org/10.1145/2934872.2934873</a>&gt;</span>. </dd>
2312c2348
< <span class="refAuthor">Iyengar, J.</span><span class="refAuthor"> and I. Swett</span>, <span class="refTitle">"QUIC Loss Detection and Congestion Control"</span>, <span class="refContent">Work in Progress</span>, <span class="seriesInfo">Internet-Draft, draft-ietf-quic-recovery-34</span>, <time datetime="2021-01-14" class="refDate">14 January 2021</time>, <span>&lt;<a href="https://tools.ietf.org/html/draft-ietf-quic-recovery-34">https://tools.ietf.org/html/draft-ietf-quic-recovery-34</a>&gt;</span>. </dd>
---
> <span class="refAuthor">Iyengar, J.</span> and <span class="refAuthor">I. Swett</span>, <span class="refTitle">"QUIC Loss Detection and Congestion Control"</span>, <span class="refContent">Work in Progress</span>, <span class="seriesInfo">Internet-Draft, draft-ietf-quic-recovery-34</span>, <time datetime="2021-01-14" class="refDate">14 January 2021</time>, <span>&lt;<a href="https://tools.ietf.org/html/draft-ietf-quic-recovery-34">https://tools.ietf.org/html/draft-ietf-quic-recovery-34</a>&gt;</span>. </dd>
2316c2352
< <span class="refAuthor">Allman, M.</span><span class="refAuthor">, Balakrishnan, H.</span><span class="refAuthor">, and S. Floyd</span>, <span class="refTitle">"Enhancing TCP's Loss Recovery Using Limited Transmit"</span>, <span class="seriesInfo">RFC 3042</span>, <span class="seriesInfo">DOI 10.17487/RFC3042</span>, <time datetime="2001-01" class="refDate">January 2001</time>, <span>&lt;<a href="https://www.rfc-editor.org/info/rfc3042">https://www.rfc-editor.org/info/rfc3042</a>&gt;</span>. </dd>
---
> <span class="refAuthor">Allman, M.</span>, <span class="refAuthor">Balakrishnan, H.</span>, and <span class="refAuthor">S. Floyd</span>, <span class="refTitle">"Enhancing TCP's Loss Recovery Using Limited Transmit"</span>, <span class="seriesInfo">RFC 3042</span>, <span class="seriesInfo">DOI 10.17487/RFC3042</span>, <time datetime="2001-01" class="refDate">January 2001</time>, <span>&lt;<a href="https://www.rfc-editor.org/info/rfc3042">https://www.rfc-editor.org/info/rfc3042</a>&gt;</span>. </dd>
2320c2356
< <span class="refAuthor">Ludwig, R.</span><span class="refAuthor"> and M. Meyer</span>, <span class="refTitle">"The Eifel Detection Algorithm for TCP"</span>, <span class="seriesInfo">RFC 3522</span>, <span class="seriesInfo">DOI 10.17487/RFC3522</span>, <time datetime="2003-04" class="refDate">April 2003</time>, <span>&lt;<a href="https://www.rfc-editor.org/info/rfc3522">https://www.rfc-editor.org/info/rfc3522</a>&gt;</span>. </dd>
---
> <span class="refAuthor">Ludwig, R.</span> and <span class="refAuthor">M. Meyer</span>, <span class="refTitle">"The Eifel Detection Algorithm for TCP"</span>, <span class="seriesInfo">RFC 3522</span>, <span class="seriesInfo">DOI 10.17487/RFC3522</span>, <time datetime="2003-04" class="refDate">April 2003</time>, <span>&lt;<a href="https://www.rfc-editor.org/info/rfc3522">https://www.rfc-editor.org/info/rfc3522</a>&gt;</span>. </dd>
2324c2360
< <span class="refAuthor">Bhandarkar, S.</span><span class="refAuthor">, Reddy, A. L. N.</span><span class="refAuthor">, Allman, M.</span><span class="refAuthor">, and E. Blanton</span>, <span class="refTitle">"Improving the Robustness of TCP to Non-Congestion Events"</span>, <span class="seriesInfo">RFC 4653</span>, <span class="seriesInfo">DOI 10.17487/RFC4653</span>, <time datetime="2006-08" class="refDate">August 2006</time>, <span>&lt;<a href="https://www.rfc-editor.org/info/rfc4653">https://www.rfc-editor.org/info/rfc4653</a>&gt;</span>. </dd>
---
> <span class="refAuthor">Bhandarkar, S.</span>, <span class="refAuthor">Reddy, A. L. N.</span>, <span class="refAuthor">Allman, M.</span>, and <span class="refAuthor">E. Blanton</span>, <span class="refTitle">"Improving the Robustness of TCP to Non-Congestion Events"</span>, <span class="seriesInfo">RFC 4653</span>, <span class="seriesInfo">DOI 10.17487/RFC4653</span>, <time datetime="2006-08" class="refDate">August 2006</time>, <span>&lt;<a href="https://www.rfc-editor.org/info/rfc4653">https://www.rfc-editor.org/info/rfc4653</a>&gt;</span>. </dd>
2328c2364
< <span class="refAuthor">Sarolahti, P.</span><span class="refAuthor">, Kojo, M.</span><span class="refAuthor">, Yamamoto, K.</span><span class="refAuthor">, and M. Hata</span>, <span class="refTitle">"Forward RTO-Recovery (F-RTO): An Algorithm for Detecting Spurious Retransmission Timeouts with TCP"</span>, <span class="seriesInfo">RFC 5682</span>, <span class="seriesInfo">DOI 10.17487/RFC5682</span>, <time datetime="2009-09" class="refDate">September 2009</time>, <span>&lt;<a href="https://www.rfc-editor.org/info/rfc5682">https://www.rfc-editor.org/info/rfc5682</a>&gt;</span>. </dd>
---
> <span class="refAuthor">Sarolahti, P.</span>, <span class="refAuthor">Kojo, M.</span>, <span class="refAuthor">Yamamoto, K.</span>, and <span class="refAuthor">M. Hata</span>, <span class="refTitle">"Forward RTO-Recovery (F-RTO): An Algorithm for Detecting Spurious Retransmission Timeouts with TCP"</span>, <span class="seriesInfo">RFC 5682</span>, <span class="seriesInfo">DOI 10.17487/RFC5682</span>, <time datetime="2009-09" class="refDate">September 2009</time>, <span>&lt;<a href="https://www.rfc-editor.org/info/rfc5682">https://www.rfc-editor.org/info/rfc5682</a>&gt;</span>. </dd>
2332c2368
< <span class="refAuthor">Allman, M.</span><span class="refAuthor">, Avrachenkov, K.</span><span class="refAuthor">, Ayesta, U.</span><span class="refAuthor">, Blanton, J.</span><span class="refAuthor">, and P. Hurtig</span>, <span class="refTitle">"Early Retransmit for TCP and Stream Control Transmission Protocol (SCTP)"</span>, <span class="seriesInfo">RFC 5827</span>, <span class="seriesInfo">DOI 10.17487/RFC5827</span>, <time datetime="2010-05" class="refDate">May 2010</time>, <span>&lt;<a href="https://www.rfc-editor.org/info/rfc5827">https://www.rfc-editor.org/info/rfc5827</a>&gt;</span>. </dd>
---
> <span class="refAuthor">Allman, M.</span>, <span class="refAuthor">Avrachenkov, K.</span>, <span class="refAuthor">Ayesta, U.</span>, <span class="refAuthor">Blanton, J.</span>, and <span class="refAuthor">P. Hurtig</span>, <span class="refTitle">"Early Retransmit for TCP and Stream Control Transmission Protocol (SCTP)"</span>, <span class="seriesInfo">RFC 5827</span>, <span class="seriesInfo">DOI 10.17487/RFC5827</span>, <time datetime="2010-05" class="refDate">May 2010</time>, <span>&lt;<a href="https://www.rfc-editor.org/info/rfc5827">https://www.rfc-editor.org/info/rfc5827</a>&gt;</span>. </dd>
2336c2372
< <span class="refAuthor">Mathis, M.</span><span class="refAuthor">, Dukkipati, N.</span><span class="refAuthor">, and Y. Cheng</span>, <span class="refTitle">"Proportional Rate Reduction for TCP"</span>, <span class="seriesInfo">RFC 6937</span>, <span class="seriesInfo">DOI 10.17487/RFC6937</span>, <time datetime="2013-05" class="refDate">May 2013</time>, <span>&lt;<a href="https://www.rfc-editor.org/info/rfc6937">https://www.rfc-editor.org/info/rfc6937</a>&gt;</span>. </dd>
---
> <span class="refAuthor">Mathis, M.</span>, <span class="refAuthor">Dukkipati, N.</span>, and <span class="refAuthor">Y. Cheng</span>, <span class="refTitle">"Proportional Rate Reduction for TCP"</span>, <span class="seriesInfo">RFC 6937</span>, <span class="seriesInfo">DOI 10.17487/RFC6937</span>, <time datetime="2013-05" class="refDate">May 2013</time>, <span>&lt;<a href="https://www.rfc-editor.org/info/rfc6937">https://www.rfc-editor.org/info/rfc6937</a>&gt;</span>. </dd>
2340c2376
< <span class="refAuthor">Hurtig, P.</span><span class="refAuthor">, Brunstrom, A.</span><span class="refAuthor">, Petlund, A.</span><span class="refAuthor">, and M. Welzl</span>, <span class="refTitle">"TCP and Stream Control Transmission Protocol (SCTP) RTO Restart"</span>, <span class="seriesInfo">RFC 7765</span>, <span class="seriesInfo">DOI 10.17487/RFC7765</span>, <time datetime="2016-02" class="refDate">February 2016</time>, <span>&lt;<a href="https://www.rfc-editor.org/info/rfc7765">https://www.rfc-editor.org/info/rfc7765</a>&gt;</span>. </dd>
---
> <span class="refAuthor">Hurtig, P.</span>, <span class="refAuthor">Brunstrom, A.</span>, <span class="refAuthor">Petlund, A.</span>, and <span class="refAuthor">M. Welzl</span>, <span class="refTitle">"TCP and Stream Control Transmission Protocol (SCTP) RTO Restart"</span>, <span class="seriesInfo">RFC 7765</span>, <span class="seriesInfo">DOI 10.17487/RFC7765</span>, <time datetime="2016-02" class="refDate">February 2016</time>, <span>&lt;<a href="https://www.rfc-editor.org/info/rfc7765">https://www.rfc-editor.org/info/rfc7765</a>&gt;</span>. </dd>
2344c2380
< <span class="refAuthor">Savage, S.</span><span class="refAuthor">, Cardwell, N.</span><span class="refAuthor">, Wetherall, D.</span><span class="refAuthor">, and T. Anderson</span>, <span class="refTitle">"TCP congestion control with a misbehaving receiver"</span>, <span class="seriesInfo">ACM Computer Communication Review 29(5)</span>, <span class="seriesInfo">DOI 10.1145/505696.505704</span>, <time datetime="1999-10" class="refDate">October 1999</time>, <span>&lt;<a href="https://doi.org/10.1145/505696.505704">https://doi.org/10.1145/505696.505704</a>&gt;</span>. </dd>
---
> <span class="refAuthor">Savage, S.</span>, <span class="refAuthor">Cardwell, N.</span>, <span class="refAuthor">Wetherall, D.</span>, and <span class="refAuthor">T. Anderson</span>, <span class="refTitle">"TCP congestion control with a misbehaving receiver"</span>, <span class="seriesInfo">ACM Computer Communication Review 29(5)</span>, <span class="seriesInfo">DOI 10.1145/505696.505704</span>, <time datetime="1999-10" class="refDate">October 1999</time>, <span>&lt;<a href="https://doi.org/10.1145/505696.505704">https://doi.org/10.1145/505696.505704</a>&gt;</span>. </dd>
2348c2384
< <span class="refAuthor">Winstein, K.</span><span class="refAuthor">, Sivaraman, A.</span><span class="refAuthor">, and H. Balakrishnan</span>, <span class="refTitle">"Stochastic Forecasts Achieve High Throughput and Low Delay over Cellular Networks"</span>, <span class="refContent">10th USENIX Symposium on Networked Systems Design and Implementation (NSDI '13)"</span>, <time datetime="2013" class="refDate">2013</time>. </dd>
---
> <span class="refAuthor">Winstein, K.</span>, <span class="refAuthor">Sivaraman, A.</span>, and <span class="refAuthor">H. Balakrishnan</span>, <span class="refTitle">"Stochastic Forecasts Achieve High Throughput and Low Delay over Cellular Networks"</span>, <span class="refContent">10th USENIX Symposium on Networked Systems Design and Implementation (NSDI '13)"</span>, <time datetime="2013" class="refDate">2013</time>. </dd>
2354c2390
< <section id="section-appendix.a">
---
> <section id="appendix-A">
2358c2394
< <p id="section-appendix.a-1">The authors thank <span class="contact-name">Matt Mathis</span> for his insights in FACK and <span class="contact-name">Michael Welzl</span> for his per-packet timer idea that inspired this work. <span class="contact-name">Eric Dumazet</span>, <span class="contact-name">Randy Stewart</span>, <span class="contact-name">Van Jacobson</span>, <span class="contact-name">Ian Swett</span>, <span class="contact-name">Rick Jones</span>, <span class="contact-name">Jana Iyengar</span>, <span class="contact-name">Hiren Panchasara</span>, <span class="contact-name">Praveen Balasubramanian</span>, <span class="contact-name">Yoshifumi Nishida</span>, <span class="contact-name">Bob Briscoe</span>, <span class="contact-name">Felix Weinrank</span>, <span class="contact-name">Michael Tüxen</span>, <span class="contact-name">Martin Duke</span>, <span class="contact-name">Ilpo Jarvinen</span>, <span class="contact-name">Theresa Enghardt</span>, <span class="contact-name">Mirja Kühlewind</span>, <span class="contact-name">Gorry Fairhurst</span>, <span class="contact-name">Markku Kojo</span>, and <span class="contact-name">Yi Huang</span> contributed to this document or the implementations in Linux, FreeBSD, Windows, and QUIC.<a href="#section-appendix.a-1" class="pilcrow">¶</a></p>
---
> <p id="appendix-A-1">The authors thank <span class="contact-name">Matt Mathis</span> for his insights in FACK and <span class="contact-name">Michael Welzl</span> for his per-packet timer idea that inspired this work. <span class="contact-name">Eric Dumazet</span>, <span class="contact-name">Randy Stewart</span>, <span class="contact-name">Van Jacobson</span>, <span class="contact-name">Ian Swett</span>, <span class="contact-name">Rick Jones</span>, <span class="contact-name">Jana Iyengar</span>, <span class="contact-name">Hiren Panchasara</span>, <span class="contact-name">Praveen Balasubramanian</span>, <span class="contact-name">Yoshifumi Nishida</span>, <span class="contact-name">Bob Briscoe</span>, <span class="contact-name">Felix Weinrank</span>, <span class="contact-name">Michael Tüxen</span>, <span class="contact-name">Martin Duke</span>, <span class="contact-name">Ilpo Jarvinen</span>, <span class="contact-name">Theresa Enghardt</span>, <span class="contact-name">Mirja Kühlewind</span>, <span class="contact-name">Gorry Fairhurst</span>, <span class="contact-name">Markku Kojo</span>, and <span class="contact-name">Yi Huang</span> contributed to this document or the implementations in Linux, FreeBSD, Windows, and QUIC.<a href="#appendix-A-1" class="pilcrow">¶</a></p>
2362c2398
< <section id="section-appendix.b">
---
> <section id="appendix-B">
